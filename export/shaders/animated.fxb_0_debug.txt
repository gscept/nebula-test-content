#version 450 core
#define gl_InstanceID gl_InstanceIndex
#define gl_VertexID gl_VertexIndex
#extension GL_GOOGLE_cpp_style_line_directive : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#define SPIRV
#define FRAGMENT_SHADER

layout(set=0, binding=5) uniform sampler Basic2DSampler;
layout(set=0, binding=6) uniform sampler PosteffectSampler;
layout(set=0, binding=7) uniform sampler PosteffectUpscaleSampler;
layout(set=3, binding=1) uniform sampler GeometryTextureSampler;
layout(set=3, binding=2) uniform sampler MaterialSampler;
layout(set=3, binding=3) uniform sampler NormalSampler;
layout(set=3, binding=4) uniform sampler CubeSampler;
layout(set=3, binding=5) uniform sampler EnvironmentSampler;
layout(set=0, binding=0) uniform 	texture2D Textures2D[2048];
layout(set=0, binding=1) uniform 	texture2DMS Textures2DMS[64];
layout(set=0, binding=2) uniform 	textureCube TexturesCube[128];
layout(set=0, binding=3) uniform 	texture3D Textures3D[128];
layout(set=0, binding=4) uniform 	texture2DArray Textures2DArray[8];
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=0) uniform 	subpassInput InputAttachment0;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=1) uniform 	subpassInput InputAttachment1;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=2) uniform 	subpassInput InputAttachment2;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=3) uniform 	subpassInput InputAttachment3;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=4) uniform 	subpassInput InputAttachment4;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=5) uniform 	subpassInput InputAttachment5;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=6) uniform 	subpassInput InputAttachment6;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=7) uniform 	subpassInput InputAttachment7;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=8) uniform 	subpassInput InputAttachment8;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=9) uniform 	subpassInput InputAttachment9;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=10) uniform 	subpassInput InputAttachment10;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=11) uniform 	subpassInput InputAttachment11;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=12) uniform 	subpassInput InputAttachment12;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=13) uniform 	subpassInput InputAttachment13;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=14) uniform 	subpassInput InputAttachment14;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=15) uniform 	subpassInput InputAttachment15;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=16) uniform 	subpassInput DepthAttachment;
#endif //FRAGMENT_SHADER
layout(set=3, binding=0) uniform 	sampler2D JointInstanceTexture;
layout(std140, set=3, binding=6) uniform GlobalBlock
{
/* Offset:0 */	float FresnelPower;
/* Offset:4 */	float FresnelStrength;
};

layout(std140, set=0, binding=8) uniform PerTickParams
{
/* Offset:0 */	vec4 WindDirection;
/* Offset:16 */	float WindWaveSize;
/* Offset:20 */	float WindSpeed;
/* Offset:24 */	float WindIntensity;
/* Offset:28 */	float WindForce;
/* Offset:32 */	float Saturation;
/* Offset:36 */	float MaxLuminance;
/* Offset:40 */	float FadeValue;
/* Offset:44 */	uint UseDof;
/* Offset:48 */	vec4 Balance;
/* Offset:64 */	vec3 DoFDistances;
/* Offset:76 */	float HDRBrightPassThreshold;
/* Offset:80 */	vec4 HDRBloomColor;
/* Offset:96 */	vec4 FogDistances;
/* Offset:112 */	vec4 FogColor;
/* Offset:128 */	uint GlobalLightFlags;
/* Offset:132 */	float GlobalLightShadowIntensity;
/* Offset:144 */	vec4 GlobalLightDirWorldspace;
/* Offset:160 */	vec4 GlobalLightDir;
/* Offset:176 */	vec4 GlobalLightColor;
/* Offset:192 */	vec4 GlobalBackLightColor;
/* Offset:208 */	vec4 GlobalAmbientLightColor;
/* Offset:224 */layout(column_major) 	mat4x4 CSMShadowMatrix;
/* Offset:288 */	float GlobalBackLightOffset;
/* Offset:292 */	uint GlobalLightShadowBuffer;
/* Offset:296 */	int NumEnvMips;
/* Offset:300 */	uint EnvironmentMap;
/* Offset:304 */	vec4 A;
/* Offset:320 */	vec4 B;
/* Offset:336 */	vec4 C;
/* Offset:352 */	vec4 D;
/* Offset:368 */	vec4 E;
/* Offset:384 */	vec4 Z;
/* Offset:400 */	float RayleighFactor;
/* Offset:404 */	float RayleighZenithLength;
/* Offset:408 */	float RefractiveIndex;
/* Offset:412 */	float DepolarizationFactor;
/* Offset:416 */	float Molecules;
/* Offset:420 */	float MieV;
/* Offset:424 */	float MieCoefficient;
/* Offset:428 */	float MieDirectionalG;
/* Offset:432 */	float MieZenithLength;
/* Offset:436 */	float Turbidity;
/* Offset:440 */	float SunIntensityFactor;
/* Offset:444 */	float SunIntensityFalloff;
/* Offset:448 */	float SunDiscSize;
/* Offset:464 */	vec3 MieKCoefficient;
/* Offset:480 */	vec3 PrimaryColors;
/* Offset:492 */	float TonemapWeight;
/* Offset:496 */	float Lum;
/* Offset:512 */	vec4 CascadeOffset[4];
/* Offset:576 */	vec4 CascadeScale[4];
/* Offset:640 */	vec4 CascadeDistances;
/* Offset:656 */	float MinBorderPadding;
/* Offset:660 */	float MaxBorderPadding;
/* Offset:664 */	float ShadowPartitionSize;
/* Offset:668 */	float GlobalLightShadowBias;
/* Offset:672 */	uint NormalBuffer;
/* Offset:676 */	uint DepthBuffer;
/* Offset:680 */	uint SpecularBuffer;
/* Offset:684 */	uint AlbedoBuffer;
/* Offset:688 */	uint EmissiveBuffer;
/* Offset:692 */	uint LightBuffer;
/* Offset:696 */	uint IrradianceMap;
/* Offset:700 */	uint DepthBufferCopy;
};

layout(std140, set=1, binding=0) uniform FrameBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 View;
/* Offset:64 */layout(column_major) 	mat4x4 InvView;
/* Offset:128 */layout(column_major) 	mat4x4 ViewProjection;
/* Offset:192 */layout(column_major) 	mat4x4 Projection;
/* Offset:256 */layout(column_major) 	mat4x4 InvProjection;
/* Offset:320 */layout(column_major) 	mat4x4 InvViewProjection;
/* Offset:384 */	vec4 EyePos;
/* Offset:400 */	vec4 FocalLengthNearFar;
/* Offset:416 */	vec4 TimeAndRandom;
};

layout(std140, set=1, binding=1) uniform ShadowMatrixBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 CSMViewMatrix[4];
/* Offset:256 */layout(column_major) 	mat4x4 LightViewMatrix[16];
};

layout(std140, set=2, binding=17) uniform PassBlock
{
/* Offset:0 */	vec4 RenderTargetDimensions[16];
};

layout(std140, set=6, binding=0) uniform ObjectBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 Model;
/* Offset:64 */layout(column_major) 	mat4x4 InvModel;
/* Offset:128 */	int ObjectId;
/* Offset:132 */	float DitherFactor;
};

layout(std140, set=6, binding=1) uniform InstancingBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 ModelArray[256];
/* Offset:16384 */layout(column_major) 	mat4x4 ModelViewArray[256];
/* Offset:32768 */layout(column_major) 	mat4x4 ModelViewProjectionArray[256];
/* Offset:49152 */	int IdArray[256];
};

layout(std140, set=6, binding=2) uniform JointBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 JointPalette[256];
};

layout(std140, set=3, binding=7) uniform DefaultSamplers
{
/* Offset:0 */	uint AlbedoMap;
/* Offset:4 */	uint DisplacementMap;
/* Offset:8 */	uint ParameterMap;
/* Offset:12 */	uint NormalMap;
};

layout(std140, set=3, binding=8) uniform MaterialParams
{
/* Offset:0 */	vec4 MatAlbedoIntensity;
/* Offset:16 */	vec4 MatSpecularIntensity;
/* Offset:32 */	vec4 MatEmissiveIntensity;
/* Offset:48 */	vec4 MatFresnelIntensity;
/* Offset:64 */	float AlphaSensitivity;
/* Offset:68 */	float AlphaBlendFactor;
/* Offset:72 */	float MatRoughnessIntensity;
/* Offset:76 */	float MatMetallicIntensity;
};

layout(std140, set=3, binding=9) uniform TessellationParams
{
/* Offset:0 */	float TessellationFactor;
/* Offset:4 */	float MaxDistance;
/* Offset:8 */	float MinDistance;
/* Offset:12 */	float HeightScale;
/* Offset:16 */	float SceneScale;
};

layout(std140, set=3, binding=10) uniform AnimationParams
{
/* Offset:0 */	vec2 AnimationDirection;
/* Offset:8 */	float AnimationAngle;
/* Offset:12 */	float AnimationLinearSpeed;
/* Offset:16 */	float AnimationAngularSpeed;
/* Offset:20 */	int NumXTiles;
/* Offset:24 */	int NumYTiles;
/* Offset:28 */	uint _padanim0;
};

const int TICK_GROUP = int(0);
const int FRAME_GROUP = int(1);
const int PASS_GROUP = int(2);
const int BATCH_GROUP = int(3);
const int INSTANCE_GROUP = int(4);
const int SYSTEM_GROUP = int(5);
const int DYNAMIC_OFFSET_GROUP = int(6);
const float depthScale = float(100);
const float MiddleGrey = float(0.5);
const float Key = float(0.300000012);
const vec4 Luminance = vec4(0.212599993, 0.715200007, 0.0722000003, 0);
const int m = int(1540483477);
const float F3 = float(0.333333313);
const float G3 = float(0.166666701);
const mat3x3 rot1 = mat3x3(-0.370000005, 0.360000014, 0.850000024, -0.140000001, -0.930000007, 0.340000004, 0.920000017, 0.00999999978, 0.400000006);
const mat3x3 rot2 = mat3x3(-0.550000012, -0.389999986, 0.74000001, 0.330000013, -0.910000026, -0.239999995, 0.769999981, 0.119999997, 0.629999995);
const mat3x3 rot3 = mat3x3(-0.709999979, 0.519999981, -0.469999999, -0.0799999982, -0.720000029, -0.680000007, -0.699999988, -0.449999988, 0.560000002);
const int MAX_2D_TEXTURES = int(2048);
const int MAX_2D_MS_TEXTURES = int(64);
const int MAX_2D_ARRAY_TEXTURES = int(8);
const int MAX_CUBE_TEXTURES = int(128);
const int MAX_3D_TEXTURES = int(128);
const int SHADOW_CASTER_COUNT = int(16);
const int MAX_INSTANCING_BATCH_SIZE = int(256);
const float RimIntensity = float(0.899999976);
const float RimPower = float(2);
const uint STENCIL_BIT_SKIN = uint(1);
const uint STENCIL_BIT_CHARACTER = uint(2);
const uint STENCIL_BIT_DYNAMIC = uint(4);
const uint STENCIL_BIT_FP = uint(8);
#line 67 "G:/nebula/nebula/work/shaders/vk/lib/std.fxh"
void
sincos(float angle, out float sinus, out float cosinus)
{
#line 69 "G:/nebula/nebula/work/shaders/vk/lib/std.fxh"
sinus = sin(angle);
	cosinus = cos(angle);
}

#line 19 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
Encode2(vec2 inVals)
{
#line 21 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4(inVals.x, fract(inVals.x * 256.0), inVals.y, fract(inVals.y * 256.0));
}

#line 29 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
Decode2(vec4 inVals)
{
#line 31 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec2(inVals.x + (inVals.y / 256.0), inVals.z + (inVals.w / 256.0));
}

#line 39 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
UnpackNormal(vec3 packedDataNormal)
{
#line 41 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (packedDataNormal * 2.0) - 1.0;
}

#line 49 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
UnpackNormal4(vec4 packedDataNormal)
{
#line 51 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4((packedDataNormal.xyz * 2.0) - 1.0, 1.0f);
}

#line 59 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
UnpackUv(vec2 packedDataUv)
{
#line 61 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (packedDataUv / 8192.0);
}

#line 70 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
UnpackWeights(vec4 weights)
{
#line 72 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (weights / dot(weights, vec4(1.0, 1.0, 1.0, 1.0)));
}

#line 135 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
ToneMap(vec4 vColor, vec4 lumAvg, float maxLum)
{
#line 146 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float L = dot(vColor, Luminance);
	float Lp = L * Key / lumAvg.x;
	float nL = (Lp * (1.0f + Lp / (MiddleGrey))) / (1.0f + Lp);




	vec3 color = vColor.rgb * (nL / L) * maxLum;



	return vec4(color, 1.0f);
}

#line 165 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
linstep(float min, float max, float v)
{
#line 167 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return clamp((v - min) / (max - min), 0.0f, 1.0f);
}

#line 179 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
void
pack_u16(in float depth, out float byte_a, out float byte_b)
{
#line 181 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float tmp = depth / 256.0f;
    byte_a = floor(tmp) / 256.0f;
    byte_b = fract(tmp);
}

#line 191 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
unpack_u16(in float byte_a, in float byte_b)
{
#line 193 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return ((byte_a * 256.0f) * 256.0f) + (byte_b * 256.0f);
}

#line 203 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
void
pack_16bit_normal_component(in float n, out float byte_a, out float byte_b)
{
#line 205 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
n = ((n * 0.5f) + 0.5f) * 65535.0f;

    pack_u16(n, byte_a, byte_b);
}

#line 214 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
unpack_16bit_normal_component(in float byte_a, in float byte_b)
{
#line 216 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return ((unpack_u16(byte_a, byte_b) / 65535.0f) - 0.5f) * 2.0f;
}

#line 223 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
pack_normalxy_into_rgba8(in float normal_x, in float normal_y)
{
#line 225 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 ret;
    pack_16bit_normal_component(normal_x, ret.x, ret.y);
    pack_16bit_normal_component(normal_y, ret.z, ret.w);
    return ret;
}

#line 235 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
unpack_normalxy_from_rgba8(in vec4 packedData)
{
#line 237 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4( unpack_16bit_normal_component(packedData.x, packedData.y),
                    unpack_16bit_normal_component(packedData.z, packedData.w),
                    0.0f,
                    0.0f);
}

#line 249 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PackViewSpaceNormal(in vec3 viewSpaceNormal)
{
#line 252 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
viewSpaceNormal = normalize(viewSpaceNormal);



    const float scale = 1.7777f;
    vec2 enc = viewSpaceNormal.xy / (viewSpaceNormal.z+1.0f);
    enc /= scale;
    enc = enc * 0.5f + 0.5f;


    vec4 normal = pack_normalxy_into_rgba8(enc.x, enc.y);
    return normal;
}

#line 271 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
UnpackViewSpaceNormal(in vec4 packedDataValue)
{
#line 274 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 unpackedData = unpack_normalxy_from_rgba8(packedDataValue);


    const float scale = 1.7777f;
    vec3 nn = unpackedData.xyz * vec3(2.0f * scale, 2.0f * scale, 0.0f) + vec3(-scale, -scale, 1.0f);
    float g = 2.0f / dot(nn.xyz, nn.xyz);
    vec3 outViewSpaceNormal;
    outViewSpaceNormal.xy = g * nn.xy;
    outViewSpaceNormal.z = g - 1.0f;
    return outViewSpaceNormal;
}

#line 295 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PackObjectDepth(in float ObjectId, in float NormalGroupId, in float depth)
{
#line 297 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 packedData;
    packedData.x = ObjectId;
    packedData.y = NormalGroupId;


    depth = depth * depthScale;
    pack_u16(depth, packedData.z, packedData.w);
    return packedData;
}

#line 316 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
UnpackDepth(in vec4 packedData)
{
#line 318 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return unpack_u16(packedData.z, packedData.w) / depthScale;
}

#line 332 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
psLightMaterial(in vec4 lightValues, in vec4 diffColor, in vec3 emsvColor, in float emsvIntensity, in vec3 specColor, in float specIntensity)
{
#line 334 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
lightValues = lightValues;
    vec4 color = diffColor;

    color.xyz *= lightValues.xyz;
    color.xyz += emsvColor * emsvIntensity;

    vec3 normedColor = normalize(lightValues.xyz);
    float maxColor = max(max(normedColor.x, normedColor.y), normedColor.z);
    normedColor /= maxColor;
    float spec = lightValues.w;
    color.xyz += specColor * specIntensity * spec * normedColor;

    return color;
}

#line 358 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
log_conv(float x0, float x, float y0, float y)
{
#line 360 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (x + log(x0 + (y0 * exp(y - x))));
}

#line 368 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetPixelSize(in sampler2D tex)
{
#line 370 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 size = textureSize(tex, 0);
	size = vec2(1.0f) / size;
	return size;
}

#line 380 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetScaledUVs(in vec2 uvs, in sampler2D tex, in vec2 dimensions)
{
#line 382 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 texSize = textureSize(tex, 0);
	uvs = uvs * (dimensions / texSize);
	return uvs;
}

#line 392 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetUV(in ivec2 pixel, in sampler2D tex)
{
#line 394 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 size = textureSize(tex, 0);
	size = pixel / size;
	return size;
}

#line 404 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2
GetPixel(in vec2 uv, in sampler2D tex)
{
#line 406 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2 size = textureSize(tex, 0);
	size = ivec2(uv * size);
	return size;
}

#line 416 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetTextureRatio(in sampler2D tex, vec2 pixelSize)
{
#line 418 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2 size = textureSize(tex, 0);
	vec2 currentTextureSize = vec2(1.0f) / size;
	return size / currentTextureSize;
}

#line 428 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
FlipY(vec2 uv)
{
#line 430 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec2(uv.x, 1.0f - uv.y);
}

#line 437 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
LinearizeDepth(float depth)
{
#line 439 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (FocalLengthNearFar.z * FocalLengthNearFar.w) / (depth * (FocalLengthNearFar.z - FocalLengthNearFar.w) + FocalLengthNearFar.w);
}

#line 446 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
DelinearizeDepth(float depth)
{
#line 448 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return -((FocalLengthNearFar.z + FocalLengthNearFar.w) * depth - (2 * FocalLengthNearFar.z)) / ((FocalLengthNearFar.z - FocalLengthNearFar.w) * depth);
}

#line 456 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
PixelToNormalized(in vec2 screenCoord, in vec2 pixelSize)
{
#line 458 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return screenCoord.xy * pixelSize.xy;
}

#line 466 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToProjection(vec2 screenCoord, float depth)
{
#line 469 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4(screenCoord * 2.0f - 1.0f, depth, 1.0f);
}

#line 477 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToView(vec2 screenCoord, float depth)
{
#line 479 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 projectionSpace = PixelToProjection(screenCoord, depth);
    vec4 viewSpace = InvProjection * projectionSpace;
    viewSpace /= viewSpace.w;
	return viewSpace;
}

#line 490 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToWorld(vec2 screenCoord, float depth)
{
#line 492 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 viewSpace = PixelToView(screenCoord, depth);
	return InvView * viewSpace;
}

#line 501 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
ViewToWorld(const vec4 viewSpace)
{
#line 503 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return InvView * viewSpace;
}

#line 511 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
GetPosition(mat4x4 transform)
{
#line 513 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return transform[2].xyz;
}

#line 522 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uvec3
Unpack1DTo3D(uint index1D, uint width, uint height)
{
#line 524 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uint i = index1D % width;
    uint j = index1D % (width * height) / width;
    uint k = index1D / (width * height);

    return uvec3(i, j, k);
}

#line 536 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uint
Pack3DTo1D(uvec3 index3D, uint width, uint height)
{
#line 538 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return index3D.x + (width * (index3D.y + height * index3D.z));
}

#line 544 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
bool
IntersectLineWithPlane(vec3 lineStart, vec3 lineEnd, vec4 plane, out vec3 intersect)
{
#line 546 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 ab = lineEnd - lineStart;
    float t = (plane.w - dot(plane.xyz, lineStart)) / dot(plane.xyz, ab);
    bool ret = (t >= 0.0f && t <= 1.0f);
    intersect = vec3(0, 0, 0);
    if (ret)
    {
        intersect = lineStart + t * ab;
    }

    return ret;
}

#line 569 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
hash11(float p)
{
#line 571 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

#line 580 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
hash12(vec2 p)
{
#line 582 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

#line 591 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
hash32(vec2 p)
{
#line 593 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yxz + 19.19);
    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
}

#line 603 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
murmur(int k)
{
#line 605 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
int h = k ^ 1;

    k *= m;
    k ^= k >> 24;
    k *= m;

    h *= m;
    h ^= k;

    return float(h);
}

#line 622 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
random3(vec3 c)
{
#line 624 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 r;
    float c1 = dot(c, vec3(17.0f, 59.4f, 15.0f));
    r.x = fract(murmur(int(c.x * c1)) / 512.0f);
    r.y = fract(murmur(int(c.y * c1)) / 512.0f);
    r.z = fract(murmur(int(c.z * c1)) / 512.0f);
    return r - 0.5f;
}

#line 641 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
simplex3D(vec3 p)
{
#line 648 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 s = floor(p + dot(p, vec3(F3)));
    vec3 x = p - s + dot(s, vec3(G3));


    vec3 e = step(vec3(0.0f), x - x.yzx);
    vec3 i1 = e * (1.0f - e.zxy);
    vec3 i2 = 1.0f - e.zxy * (1.0f - e);


    vec3 x1 = x - i1 + G3;
    vec3 x2 = x - i2 + 2.0f * G3;
    vec3 x3 = x - 1.0f + 3.0f * G3;


    vec4 w, d;


    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);


    w = max(0.6f - w, 0.0f);


    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0f), x3);


    w *= w;
    w *= w;
    d *= w;


    return dot(d, vec4(52.0f));
}

#line 696 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
simplex3D_fractal(vec3 m)
{
#line 698 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return 0.5333333f * simplex3D(m * rot1)
        + 0.2666667f * simplex3D(2.0f * m * rot2)
        + 0.1333333f * simplex3D(4.0f * m * rot3)
        + 0.0666667f * simplex3D(8.0f * m);
}

#line 18 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
vec4
SkinnedPosition(const vec3 inPos, const vec4 weights, const uvec4 indices)
{
#line 21 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
vec4 normWeights = weights / dot(weights, vec4(1.0));


	mat4x4 joint = JointPalette[indices[0]] * normWeights[0] +
				   JointPalette[indices[1]] * normWeights[1] +
				   JointPalette[indices[2]] * normWeights[2] +
				   JointPalette[indices[3]] * normWeights[3];
	return joint * vec4(inPos, 1);
}

#line 36 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
vec4
SkinnedPositionInstanced(const vec3 inPos, const vec4 weights, const uvec4 indices, const uint ID)
{
#line 39 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
vec4 normWeights = weights / dot(weights, vec4(1.0));
	mat4x4 joint = JointPalette[indices[0]] * normWeights[0] +
				   JointPalette[indices[1]] * normWeights[1] +
				   JointPalette[indices[2]] * normWeights[2] +
				   JointPalette[indices[3]] * normWeights[3];
	return joint * vec4(inPos, 1);
}

#line 52 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
vec4
SkinnedNormal(const vec3 inNormal, const vec4 weights, const uvec4 indices)
{
#line 55 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
mat4x4 joint = JointPalette[indices[0]] * weights[0] +
				   JointPalette[indices[1]] * weights[1] +
				   JointPalette[indices[2]] * weights[2] +
				   JointPalette[indices[3]] * weights[3];
	return joint * vec4(inNormal, 0);
}

#line 67 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
vec4
SkinnedNormalInstanced(const vec3 inNormal, const vec4 weights, const uvec4 indices, const uint ID)
{
#line 69 "G:/nebula/nebula/work/shaders/vk/lib/skinning.fxh"
mat4x4 joint = JointPalette[indices[0]] * weights[0] +
				   JointPalette[indices[1]] * weights[1] +
				   JointPalette[indices[2]] * weights[2] +
				   JointPalette[indices[3]] * weights[3];
	return joint * vec4(inNormal, 0);
}

#line 26 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
RimLightIntensity(vec3 worldNormal, vec3 worldEyeVec)
{
#line 28 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float rimIntensity = pow(abs(1.0f - abs(dot(worldNormal, worldEyeVec))), RimPower);
    rimIntensity *= RimIntensity;
    return rimIntensity;
}

#line 38 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec3
FresnelSchlick(vec3 spec, float dotprod)
{
#line 40 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float base = 1.0 - clamp(dotprod, 0.0f, 1.0f);
	float exponent = pow(base, 5);
	return spec + (1 - spec) * exponent;
}

#line 50 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec3
FresnelSchlickGloss(vec3 spec, float dotprod, float roughness)
{
#line 52 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float base = 1.0 - clamp(dotprod, 0.0f, 1.0f);
	float exponent = pow(base, 5);
	return spec + (max(vec3(1 - roughness), spec) - spec) * exponent;
}

#line 63 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
NormalDistributionGGX(in float NdotH, in float roughness)
{
#line 65 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float a = pow(roughness, 4);
	float NdotH2 = NdotH * NdotH;

	float denom = (NdotH2 * (a - 1.0f) + 1.0f);
	denom = 3.14159265 * denom * denom;

	return (a / (denom + 0.00001f));
}

#line 80 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
GeometrySchlickGGX(in float NdotV, in float k)
{
#line 82 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float denom = fma(NdotV,1.0f - k,k);
	return NdotV / denom;
}

#line 90 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
GeometrySmith(in float NdotV, in float NdotL, in float roughness)
{
#line 92 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float r = roughness + 1.0f;
	float k = (r*r) * 0.125f;
	float ggxNV = GeometrySchlickGGX(NdotV, k);
	float ggxNL = GeometrySchlickGGX(NdotL, k);
	return ggxNV * ggxNL;
}

#line 104 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
void
CalculateF0(in vec3 color, in float metallic, inout vec3 F0)
{
#line 109 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
F0 = mix(F0, color.rgb, metallic);
}

#line 125 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
void
CalculateBRDF(float NdotH, float NdotL, float NdotV, float cosTheta, float roughness, vec3 F0, out vec3 F, out vec3 brdf)
{
#line 129 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
F = FresnelSchlickGloss(F0, max(cosTheta, 0.0), roughness);

    float NDF = NormalDistributionGGX(NdotH, roughness);
    float G = GeometrySmith(NdotV, NdotL, roughness);


    vec3 nominator = NDF * G * F;
    float denominator = 4 * NdotV * NdotL + 0.001f;
    brdf = nominator / denominator;
}

#line 152 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
void
BRDFLighting(float NH, float NL, float NV, float HL, float specPower, vec3 specColor, out vec3 spec)
{
#line 154 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float normalizationTerm = (specPower + 2.0f) / 8.0f;
	float blinnPhong = pow(NH, specPower);
	float specularTerm = blinnPhong;
	float cosineTerm = NL;
	vec3 fresnelTerm = FresnelSchlick(specColor, HL);
	float alpha = 1.0f / ( sqrt ( 3.14159265/4.0f * specPower + 3.14159265/2.0f) );
	float visibilityTerm = (NL * (1.0f - alpha) + alpha ) * (NV * ( 1.0f - alpha ) + alpha );
	visibilityTerm = 1.0f / visibilityTerm;
	spec = specularTerm * cosineTerm * fresnelTerm * visibilityTerm;
}

#line 171 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec4
ConvertOSM(in vec4 material)
{
#line 173 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec4 ret;
	ret[0] = material.b;
	ret[1] = 1 - material.g;
	ret[2] = 1 - material.r;
	ret[3] = material.a;
	return ret;
}

#line 207 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3
PBRSpec(in vec4 specularColor, in vec3 worldNormal, in vec3 viewSpacePos, in vec3 worldViewVec, in mat4x4 view, in float roughness)
{
#line 209 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3 ret;
	vec3 viewNorm = (view * vec4(worldNormal, 0)).xyz;
	vec3 reflectVec = reflect(worldViewVec, worldNormal.xyz);
	float x = dot(-viewNorm, normalize(viewSpacePos));
	vec3 rim = FresnelSchlickGloss(specularColor.rgb, x, roughness);
	ret[1] = textureLod(samplerCube(TexturesCube[EnvironmentMap], CubeSampler), reflectVec, (1.0f - pow(roughness, 2)) * NumEnvMips).rgb * rim;
	ret[0] = textureLod(samplerCube(TexturesCube[IrradianceMap], CubeSampler), worldNormal.xyz, 0).rgb;
	return ret;
}

#line 56 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec4
SimpleColor(in vec4 albedoColor)
{
#line 58 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
return vec4(albedoColor.rgb, 1.0f);
}

#line 62 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec4
AlphaColor(in vec4 albedoColor)
{
#line 64 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
return albedoColor;
}

#line 78 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec3
NormalMapFunctorDXT5NM(in vec3 tangent, in vec3 binormal, in vec3 normal, in vec4 bumpData)
{
#line 80 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat3 tangentViewMatrix = mat3(normalize(tangent.xyz), normalize(binormal.xyz), normalize(normal.xyz));
	vec3 tNormal = vec3(0,0,0);
	tNormal.xy = (bumpData.ag * 2.0f) - 1.0f;
	tNormal.z = clamp(sqrt(1.0f - dot(tNormal.xy, tNormal.xy)), 0.0f, 1.0f);
	return tangentViewMatrix * tNormal;
}

#line 91 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec3
NormalMapFunctor(in vec3 tangent, in vec3 binormal, in vec3 normal, in vec4 bumpData)
{
#line 93 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat3 tangentViewMatrix = mat3(normalize(tangent.xyz), normalize(binormal.xyz), normalize(normal.xyz));
	vec3 tNormal = vec3(0,0,0);
	tNormal.xy = (bumpData.xy * 2.0f) - 1.0f;
	tNormal.z = clamp(sqrt(1.0f - dot(tNormal.xy, tNormal.xy)), 0.0f, 1.0f);
	return tangentViewMatrix * tNormal;
}

#line 104 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec3
FlatNormalFunctor(in vec3 tangent, in vec3 binormal, in vec3 normal, in vec4 bumpData)
{
#line 106 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
return normal;
}

#line 117 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec4
DefaultMaterialFunctor(in vec4 material)
{
#line 119 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
return material;
}

#line 124 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec4
OSMMaterialFunctor(in vec4 material)
{
#line 126 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
return ConvertOSM(material);
}

#line 146 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3
PBR(in vec4 specularColor, in vec3 worldNormal, in vec3 worldViewVec, in float roughness)
{
#line 148 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3 ret;
	vec3 reflectVec = reflect(worldViewVec, worldNormal.xyz);
	vec3 viewNorm = (View * vec4(worldNormal, 0)).xyz;
	float x = dot(-viewNorm, normalize(worldViewVec));
	vec3 rim = FresnelSchlickGloss(specularColor.rgb, x, roughness);
	ret[1] = textureLod(samplerCube(TexturesCube[EnvironmentMap], CubeSampler), reflectVec, (1.0f - roughness) * NumEnvMips).rgb * rim;
	ret[0] = textureLod(samplerCube(TexturesCube[IrradianceMap], CubeSampler), worldNormal.xyz, 0).rgb;
	return ret;
}

#line 162 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3
ReflectionOnly(in vec4 specularColor, in vec3 worldNormal, in vec3 worldViewVec, in float roughness)
{
#line 164 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3 ret;
	vec3 reflectVec = reflect(worldViewVec, worldNormal.xyz);
	vec3 viewNorm = (View * vec4(worldNormal, 0)).xyz;
	float x = dot(-viewNorm, normalize(worldViewVec));
	vec3 rim = FresnelSchlickGloss(specularColor.rgb, x, roughness);
	ret[1] = textureLod(samplerCube(TexturesCube[EnvironmentMap], CubeSampler), reflectVec, (1.0f - pow(roughness, 2)) * NumEnvMips).rgb * rim;
	ret[0] = vec3(0);
	return ret;
}

#line 178 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3
IrradianceOnly(in vec4 specularColor, in vec3 worldNormal, in vec3 worldViewVec, in float roughness)
{
#line 180 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3 ret;
	ret[1] = vec3(0);
	ret[0] = textureLod(samplerCube(TexturesCube[IrradianceMap], CubeSampler), worldNormal.xyz, 0).rgb;
	return ret;
}

#line 190 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3
NoEnvironment(in vec4 specularColor, in vec3 worldNormal, in vec3 worldViewVec, in float roughness)
{
#line 192 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
mat2x3 ret;
	ret[1] = vec3(0);
	ret[0] = vec3(0);
	return ret;
}

	layout(location = 0) in vec3 Tangent;
	layout(location = 1) in vec3 Normal;
	layout(location = 2) in vec3 Binormal;
	layout(location = 3) in vec2 UV;
	layout(location = 4) in vec3 WorldViewVec;
	layout(location = 0) out vec4 Albedo;
	layout(location = 1) out vec3 Normals;
	layout(location = 2) out vec4 Material;
#line 579 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
void
main()
{
#line 581 "G:/nebula/nebula/work/shaders/vk/lib/geometrybase.fxh"
vec2 seed = gl_FragCoord.xy * RenderTargetDimensions[0].zw;
	float dither = hash12(seed);
	if (dither < DitherFactor)
		discard;

	vec4 albedo = AlphaColor(texture(sampler2D(Textures2D[AlbedoMap], MaterialSampler), UV)) * MatAlbedoIntensity;
	vec4 material = DefaultMaterialFunctor(texture(sampler2D(Textures2D[ParameterMap], MaterialSampler), UV));
	vec4 normals = texture(sampler2D(Textures2D[NormalMap], NormalSampler), UV);

	vec3 bumpNormal = normalize(NormalMapFunctor(Tangent, Binormal, Normal, normals));

	Albedo = albedo;
	Normals = bumpNormal;
	Material = material;
}
