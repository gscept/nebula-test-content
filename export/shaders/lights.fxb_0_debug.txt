#version 450 core
#define gl_InstanceID gl_InstanceIndex
#define gl_VertexID gl_VertexIndex
#extension GL_GOOGLE_cpp_style_line_directive : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#define SPIRV
#define FRAGMENT_SHADER

layout(set=0, binding=5) uniform sampler Basic2DSampler;
layout(set=0, binding=6) uniform sampler PosteffectSampler;
layout(set=0, binding=7) uniform sampler PosteffectUpscaleSampler;
layout(set=3, binding=0) uniform sampler GeometryTextureSampler;
layout(set=3, binding=1) uniform sampler MaterialSampler;
layout(set=3, binding=2) uniform sampler NormalSampler;
layout(set=3, binding=3) uniform sampler CubeSampler;
layout(set=3, binding=4) uniform sampler EnvironmentSampler;
layout(set=3, binding=5) uniform sampler ShadowSampler;
layout(set=3, binding=6) uniform sampler CSMTextureSampler;
layout(set=3, binding=7) uniform sampler PointLightTextureSampler;
layout(set=3, binding=8) uniform sampler SpotlightTextureSampler;
layout(set=0, binding=0) uniform 	texture2D Textures2D[2048];
layout(set=0, binding=1) uniform 	texture2DMS Textures2DMS[64];
layout(set=0, binding=2) uniform 	textureCube TexturesCube[128];
layout(set=0, binding=3) uniform 	texture3D Textures3D[128];
layout(set=0, binding=4) uniform 	texture2DArray Textures2DArray[8];
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=0) uniform 	subpassInput InputAttachment0;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=1) uniform 	subpassInput InputAttachment1;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=2) uniform 	subpassInput InputAttachment2;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=3) uniform 	subpassInput InputAttachment3;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=4) uniform 	subpassInput InputAttachment4;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=5) uniform 	subpassInput InputAttachment5;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=6) uniform 	subpassInput InputAttachment6;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=7) uniform 	subpassInput InputAttachment7;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=8) uniform 	subpassInput InputAttachment8;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=9) uniform 	subpassInput InputAttachment9;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=10) uniform 	subpassInput InputAttachment10;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=11) uniform 	subpassInput InputAttachment11;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=12) uniform 	subpassInput InputAttachment12;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=13) uniform 	subpassInput InputAttachment13;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=14) uniform 	subpassInput InputAttachment14;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=15) uniform 	subpassInput InputAttachment15;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=16) uniform 	subpassInput DepthAttachment;
#endif //FRAGMENT_SHADER
layout(std140, set=0, binding=8) uniform PerTickParams
{
/* Offset:0 */	vec4 WindDirection;
/* Offset:16 */	float WindWaveSize;
/* Offset:20 */	float WindSpeed;
/* Offset:24 */	float WindIntensity;
/* Offset:28 */	float WindForce;
/* Offset:32 */	float Saturation;
/* Offset:36 */	float MaxLuminance;
/* Offset:40 */	float FadeValue;
/* Offset:44 */	uint UseDof;
/* Offset:48 */	vec4 Balance;
/* Offset:64 */	vec3 DoFDistances;
/* Offset:76 */	float HDRBrightPassThreshold;
/* Offset:80 */	vec4 HDRBloomColor;
/* Offset:96 */	vec4 FogDistances;
/* Offset:112 */	vec4 FogColor;
/* Offset:128 */	uint GlobalLightFlags;
/* Offset:132 */	float GlobalLightShadowIntensity;
/* Offset:144 */	vec4 GlobalLightDirWorldspace;
/* Offset:160 */	vec4 GlobalLightDir;
/* Offset:176 */	vec4 GlobalLightColor;
/* Offset:192 */	vec4 GlobalBackLightColor;
/* Offset:208 */	vec4 GlobalAmbientLightColor;
/* Offset:224 */layout(column_major) 	mat4x4 CSMShadowMatrix;
/* Offset:288 */	float GlobalBackLightOffset;
/* Offset:292 */	uint GlobalLightShadowBuffer;
/* Offset:296 */	int NumEnvMips;
/* Offset:300 */	uint EnvironmentMap;
/* Offset:304 */	vec4 A;
/* Offset:320 */	vec4 B;
/* Offset:336 */	vec4 C;
/* Offset:352 */	vec4 D;
/* Offset:368 */	vec4 E;
/* Offset:384 */	vec4 Z;
/* Offset:400 */	float RayleighFactor;
/* Offset:404 */	float RayleighZenithLength;
/* Offset:408 */	float RefractiveIndex;
/* Offset:412 */	float DepolarizationFactor;
/* Offset:416 */	float Molecules;
/* Offset:420 */	float MieV;
/* Offset:424 */	float MieCoefficient;
/* Offset:428 */	float MieDirectionalG;
/* Offset:432 */	float MieZenithLength;
/* Offset:436 */	float Turbidity;
/* Offset:440 */	float SunIntensityFactor;
/* Offset:444 */	float SunIntensityFalloff;
/* Offset:448 */	float SunDiscSize;
/* Offset:464 */	vec3 MieKCoefficient;
/* Offset:480 */	vec3 PrimaryColors;
/* Offset:492 */	float TonemapWeight;
/* Offset:496 */	float Lum;
/* Offset:512 */	vec4 CascadeOffset[4];
/* Offset:576 */	vec4 CascadeScale[4];
/* Offset:640 */	vec4 CascadeDistances;
/* Offset:656 */	float MinBorderPadding;
/* Offset:660 */	float MaxBorderPadding;
/* Offset:664 */	float ShadowPartitionSize;
/* Offset:668 */	float GlobalLightShadowBias;
/* Offset:672 */	uint NormalBuffer;
/* Offset:676 */	uint DepthBuffer;
/* Offset:680 */	uint SpecularBuffer;
/* Offset:684 */	uint AlbedoBuffer;
/* Offset:688 */	uint EmissiveBuffer;
/* Offset:692 */	uint LightBuffer;
/* Offset:696 */	uint IrradianceMap;
/* Offset:700 */	uint DepthBufferCopy;
};

layout(std140, set=1, binding=0) uniform FrameBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 View;
/* Offset:64 */layout(column_major) 	mat4x4 InvView;
/* Offset:128 */layout(column_major) 	mat4x4 ViewProjection;
/* Offset:192 */layout(column_major) 	mat4x4 Projection;
/* Offset:256 */layout(column_major) 	mat4x4 InvProjection;
/* Offset:320 */layout(column_major) 	mat4x4 InvViewProjection;
/* Offset:384 */	vec4 EyePos;
/* Offset:400 */	vec4 FocalLengthNearFar;
/* Offset:416 */	vec4 TimeAndRandom;
};

layout(std140, set=1, binding=1) uniform ShadowMatrixBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 CSMViewMatrix[4];
/* Offset:256 */layout(column_major) 	mat4x4 LightViewMatrix[16];
};

layout(std140, set=2, binding=17) uniform PassBlock
{
/* Offset:0 */	vec4 RenderTargetDimensions[16];
};

layout(std140, set=3, binding=10) uniform DefaultSamplers
{
/* Offset:0 */	uint AlbedoMap;
/* Offset:4 */	uint DisplacementMap;
/* Offset:8 */	uint ParameterMap;
/* Offset:12 */	uint NormalMap;
};

layout(std140, set=4, binding=0) uniform LocalLightBlock
{
/* Offset:0 */	vec4 LightColor;
/* Offset:16 */	vec4 LightPosRange;
/* Offset:32 */layout(column_major) 	mat4x4 LightProjTransform;
/* Offset:96 */layout(column_major) 	mat4x4 LightTransform;
/* Offset:160 */	vec4 LightForward;
/* Offset:176 */	vec2 LightCutoff;
/* Offset:184 */	uint Flags;
/* Offset:188 */	uint ProjectionTexture;
};

layout(std140, set=4, binding=1) uniform LocalLightShadowBlock
{
/* Offset:0 */	vec4 ShadowOffsetScale;
/* Offset:16 */	vec4 ShadowConstants;
/* Offset:32 */	float ShadowBias;
/* Offset:36 */	float ShadowIntensity;
/* Offset:40 */	uint ShadowMap;
/* Offset:48 */layout(column_major) 	mat4x4 ShadowProjTransform;
};

const int TICK_GROUP = int(0);
const int FRAME_GROUP = int(1);
const int PASS_GROUP = int(2);
const int BATCH_GROUP = int(3);
const int INSTANCE_GROUP = int(4);
const int SYSTEM_GROUP = int(5);
const int DYNAMIC_OFFSET_GROUP = int(6);
const int MAX_2D_TEXTURES = int(2048);
const int MAX_2D_MS_TEXTURES = int(64);
const int MAX_2D_ARRAY_TEXTURES = int(8);
const int MAX_CUBE_TEXTURES = int(128);
const int MAX_3D_TEXTURES = int(128);
const int SHADOW_CASTER_COUNT = int(16);
const float depthScale = float(100);
const float MiddleGrey = float(0.5);
const float Key = float(0.300000012);
const vec4 Luminance = vec4(0.212599993, 0.715200007, 0.0722000003, 0);
const int m = int(1540483477);
const float F3 = float(0.333333313);
const float G3 = float(0.166666701);
const mat3x3 rot1 = mat3x3(-0.370000005, 0.360000014, 0.850000024, -0.140000001, -0.930000007, 0.340000004, 0.920000017, 0.00999999978, 0.400000006);
const mat3x3 rot2 = mat3x3(-0.550000012, -0.389999986, 0.74000001, 0.330000013, -0.910000026, -0.239999995, 0.769999981, 0.119999997, 0.629999995);
const mat3x3 rot3 = mat3x3(-0.709999979, 0.519999981, -0.469999999, -0.0799999982, -0.720000029, -0.680000007, -0.699999988, -0.449999988, 0.560000002);
const float DepthScaling = float(5);
const float DarkeningFactor = float(1);
const float ShadowConstant = float(100);
const int SplitsPerRow = int(1);
const int SplitsPerColumn = int(1);
const vec4 DebugColors[8] = vec4[8](vec4(1.5, 0, 0, 1), vec4(0, 1.5, 0, 1), vec4(0, 0, 5.5, 1), vec4(1.5, 0, 5.5, 1), vec4(1.5, 1.5, 0, 1), vec4(1, 1, 1, 1), vec4(0, 1, 5.5, 1), vec4(0.5, 3.5, 0.75, 1));
const float CascadeBlendArea = float(0.200000003);
const vec2 sampleOffsets[12] = vec2[12](vec2(-0.326000005, -0.405999988), vec2(-0.839999974, -0.074000001), vec2(-0.69599998, 0.456999987), vec2(-0.202999994, 0.620999992), vec2(0.962000012, -0.194999993), vec2(0.47299999, -0.479999989), vec2(0.518999994, 0.76700002), vec2(0.185000002, -0.893000007), vec2(0.507000029, 0.064000003), vec2(0.896000028, 0.412), vec2(-0.321999997, -0.933000028), vec2(-0.791999996, -0.59799999));
const float RimIntensity = float(0.899999976);
const float RimPower = float(2);
const float specPower = float(32);
const float rimLighting = float(0.200000003);
const float exaggerateSpec = float(1.79999995);
const vec3 luminanceValue = vec3(0.298999995, 0.587000012, 0.114);
const uint USE_SHADOW_BITFLAG = uint(1);
const uint USE_PROJECTION_TEX_BITFLAG = uint(2);
#line 67 "G:/nebula/nebula/work/shaders/vk/lib/std.fxh"
void
sincos(float angle, out float sinus, out float cosinus)
{
#line 69 "G:/nebula/nebula/work/shaders/vk/lib/std.fxh"
sinus = sin(angle);
	cosinus = cos(angle);
}

#line 19 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
Encode2(vec2 inVals)
{
#line 21 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4(inVals.x, fract(inVals.x * 256.0), inVals.y, fract(inVals.y * 256.0));
}

#line 29 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
Decode2(vec4 inVals)
{
#line 31 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec2(inVals.x + (inVals.y / 256.0), inVals.z + (inVals.w / 256.0));
}

#line 39 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
UnpackNormal(vec3 packedDataNormal)
{
#line 41 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (packedDataNormal * 2.0) - 1.0;
}

#line 49 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
UnpackNormal4(vec4 packedDataNormal)
{
#line 51 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4((packedDataNormal.xyz * 2.0) - 1.0, 1.0f);
}

#line 59 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
UnpackUv(vec2 packedDataUv)
{
#line 61 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (packedDataUv / 8192.0);
}

#line 70 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
UnpackWeights(vec4 weights)
{
#line 72 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (weights / dot(weights, vec4(1.0, 1.0, 1.0, 1.0)));
}

#line 135 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
ToneMap(vec4 vColor, vec4 lumAvg, float maxLum)
{
#line 146 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float L = dot(vColor, Luminance);
	float Lp = L * Key / lumAvg.x;
	float nL = (Lp * (1.0f + Lp / (MiddleGrey))) / (1.0f + Lp);




	vec3 color = vColor.rgb * (nL / L) * maxLum;



	return vec4(color, 1.0f);
}

#line 165 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
linstep(float min, float max, float v)
{
#line 167 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return clamp((v - min) / (max - min), 0.0f, 1.0f);
}

#line 179 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
void
pack_u16(in float depth, out float byte_a, out float byte_b)
{
#line 181 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float tmp = depth / 256.0f;
    byte_a = floor(tmp) / 256.0f;
    byte_b = fract(tmp);
}

#line 191 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
unpack_u16(in float byte_a, in float byte_b)
{
#line 193 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return ((byte_a * 256.0f) * 256.0f) + (byte_b * 256.0f);
}

#line 203 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
void
pack_16bit_normal_component(in float n, out float byte_a, out float byte_b)
{
#line 205 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
n = ((n * 0.5f) + 0.5f) * 65535.0f;

    pack_u16(n, byte_a, byte_b);
}

#line 214 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
unpack_16bit_normal_component(in float byte_a, in float byte_b)
{
#line 216 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return ((unpack_u16(byte_a, byte_b) / 65535.0f) - 0.5f) * 2.0f;
}

#line 223 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
pack_normalxy_into_rgba8(in float normal_x, in float normal_y)
{
#line 225 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 ret;
    pack_16bit_normal_component(normal_x, ret.x, ret.y);
    pack_16bit_normal_component(normal_y, ret.z, ret.w);
    return ret;
}

#line 235 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
unpack_normalxy_from_rgba8(in vec4 packedData)
{
#line 237 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4( unpack_16bit_normal_component(packedData.x, packedData.y),
                    unpack_16bit_normal_component(packedData.z, packedData.w),
                    0.0f,
                    0.0f);
}

#line 249 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PackViewSpaceNormal(in vec3 viewSpaceNormal)
{
#line 252 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
viewSpaceNormal = normalize(viewSpaceNormal);



    const float scale = 1.7777f;
    vec2 enc = viewSpaceNormal.xy / (viewSpaceNormal.z+1.0f);
    enc /= scale;
    enc = enc * 0.5f + 0.5f;


    vec4 normal = pack_normalxy_into_rgba8(enc.x, enc.y);
    return normal;
}

#line 271 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
UnpackViewSpaceNormal(in vec4 packedDataValue)
{
#line 274 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 unpackedData = unpack_normalxy_from_rgba8(packedDataValue);


    const float scale = 1.7777f;
    vec3 nn = unpackedData.xyz * vec3(2.0f * scale, 2.0f * scale, 0.0f) + vec3(-scale, -scale, 1.0f);
    float g = 2.0f / dot(nn.xyz, nn.xyz);
    vec3 outViewSpaceNormal;
    outViewSpaceNormal.xy = g * nn.xy;
    outViewSpaceNormal.z = g - 1.0f;
    return outViewSpaceNormal;
}

#line 295 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PackObjectDepth(in float ObjectId, in float NormalGroupId, in float depth)
{
#line 297 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 packedData;
    packedData.x = ObjectId;
    packedData.y = NormalGroupId;


    depth = depth * depthScale;
    pack_u16(depth, packedData.z, packedData.w);
    return packedData;
}

#line 316 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
UnpackDepth(in vec4 packedData)
{
#line 318 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return unpack_u16(packedData.z, packedData.w) / depthScale;
}

#line 332 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
psLightMaterial(in vec4 lightValues, in vec4 diffColor, in vec3 emsvColor, in float emsvIntensity, in vec3 specColor, in float specIntensity)
{
#line 334 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
lightValues = lightValues;
    vec4 color = diffColor;

    color.xyz *= lightValues.xyz;
    color.xyz += emsvColor * emsvIntensity;

    vec3 normedColor = normalize(lightValues.xyz);
    float maxColor = max(max(normedColor.x, normedColor.y), normedColor.z);
    normedColor /= maxColor;
    float spec = lightValues.w;
    color.xyz += specColor * specIntensity * spec * normedColor;

    return color;
}

#line 358 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
log_conv(float x0, float x, float y0, float y)
{
#line 360 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (x + log(x0 + (y0 * exp(y - x))));
}

#line 368 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetPixelSize(in sampler2D tex)
{
#line 370 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 size = textureSize(tex, 0);
	size = vec2(1.0f) / size;
	return size;
}

#line 380 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetScaledUVs(in vec2 uvs, in sampler2D tex, in vec2 dimensions)
{
#line 382 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 texSize = textureSize(tex, 0);
	uvs = uvs * (dimensions / texSize);
	return uvs;
}

#line 392 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetUV(in ivec2 pixel, in sampler2D tex)
{
#line 394 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 size = textureSize(tex, 0);
	size = pixel / size;
	return size;
}

#line 404 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2
GetPixel(in vec2 uv, in sampler2D tex)
{
#line 406 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2 size = textureSize(tex, 0);
	size = ivec2(uv * size);
	return size;
}

#line 416 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetTextureRatio(in sampler2D tex, vec2 pixelSize)
{
#line 418 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2 size = textureSize(tex, 0);
	vec2 currentTextureSize = vec2(1.0f) / size;
	return size / currentTextureSize;
}

#line 428 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
FlipY(vec2 uv)
{
#line 430 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec2(uv.x, 1.0f - uv.y);
}

#line 437 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
LinearizeDepth(float depth)
{
#line 439 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (FocalLengthNearFar.z * FocalLengthNearFar.w) / (depth * (FocalLengthNearFar.z - FocalLengthNearFar.w) + FocalLengthNearFar.w);
}

#line 446 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
DelinearizeDepth(float depth)
{
#line 448 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return -((FocalLengthNearFar.z + FocalLengthNearFar.w) * depth - (2 * FocalLengthNearFar.z)) / ((FocalLengthNearFar.z - FocalLengthNearFar.w) * depth);
}

#line 456 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
PixelToNormalized(in vec2 screenCoord, in vec2 pixelSize)
{
#line 458 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return screenCoord.xy * pixelSize.xy;
}

#line 466 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToProjection(vec2 screenCoord, float depth)
{
#line 469 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4(screenCoord * 2.0f - 1.0f, depth, 1.0f);
}

#line 477 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToView(vec2 screenCoord, float depth)
{
#line 479 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 projectionSpace = PixelToProjection(screenCoord, depth);
    vec4 viewSpace = InvProjection * projectionSpace;
    viewSpace /= viewSpace.w;
	return viewSpace;
}

#line 490 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToWorld(vec2 screenCoord, float depth)
{
#line 492 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 viewSpace = PixelToView(screenCoord, depth);
	return InvView * viewSpace;
}

#line 501 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
ViewToWorld(const vec4 viewSpace)
{
#line 503 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return InvView * viewSpace;
}

#line 511 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
GetPosition(mat4x4 transform)
{
#line 513 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return transform[2].xyz;
}

#line 522 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uvec3
Unpack1DTo3D(uint index1D, uint width, uint height)
{
#line 524 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uint i = index1D % width;
    uint j = index1D % (width * height) / width;
    uint k = index1D / (width * height);

    return uvec3(i, j, k);
}

#line 536 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uint
Pack3DTo1D(uvec3 index3D, uint width, uint height)
{
#line 538 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return index3D.x + (width * (index3D.y + height * index3D.z));
}

#line 544 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
bool
IntersectLineWithPlane(vec3 lineStart, vec3 lineEnd, vec4 plane, out vec3 intersect)
{
#line 546 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 ab = lineEnd - lineStart;
    float t = (plane.w - dot(plane.xyz, lineStart)) / dot(plane.xyz, ab);
    bool ret = (t >= 0.0f && t <= 1.0f);
    intersect = vec3(0, 0, 0);
    if (ret)
    {
        intersect = lineStart + t * ab;
    }

    return ret;
}

#line 569 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
hash11(float p)
{
#line 571 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

#line 580 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
hash12(vec2 p)
{
#line 582 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

#line 591 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
hash32(vec2 p)
{
#line 593 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yxz + 19.19);
    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
}

#line 603 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
murmur(int k)
{
#line 605 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
int h = k ^ 1;

    k *= m;
    k ^= k >> 24;
    k *= m;

    h *= m;
    h ^= k;

    return float(h);
}

#line 622 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
random3(vec3 c)
{
#line 624 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 r;
    float c1 = dot(c, vec3(17.0f, 59.4f, 15.0f));
    r.x = fract(murmur(int(c.x * c1)) / 512.0f);
    r.y = fract(murmur(int(c.y * c1)) / 512.0f);
    r.z = fract(murmur(int(c.z * c1)) / 512.0f);
    return r - 0.5f;
}

#line 641 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
simplex3D(vec3 p)
{
#line 648 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 s = floor(p + dot(p, vec3(F3)));
    vec3 x = p - s + dot(s, vec3(G3));


    vec3 e = step(vec3(0.0f), x - x.yzx);
    vec3 i1 = e * (1.0f - e.zxy);
    vec3 i2 = 1.0f - e.zxy * (1.0f - e);


    vec3 x1 = x - i1 + G3;
    vec3 x2 = x - i2 + 2.0f * G3;
    vec3 x3 = x - 1.0f + 3.0f * G3;


    vec4 w, d;


    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);


    w = max(0.6f - w, 0.0f);


    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0f), x3);


    w *= w;
    w *= w;
    d *= w;


    return dot(d, vec4(52.0f));
}

#line 696 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
simplex3D_fractal(vec3 m)
{
#line 698 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return 0.5333333f * simplex3D(m * rot1)
        + 0.2666667f * simplex3D(2.0f * m * rot2)
        + 0.1333333f * simplex3D(4.0f * m * rot3)
        + 0.0666667f * simplex3D(8.0f * m);
}

#line 614 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float
Variance(vec2 shadowSample, float lightSpaceDepth, float tolerance)
{
#line 617 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float avgZ = shadowSample.x;
	float avgZ2 = shadowSample.y;


	if (lightSpaceDepth <= avgZ)
	{
		return 1.0f;
	}
	else
	{
		float variance = (avgZ2) - (avgZ * avgZ);
		variance = min(1.0f, max(0.0f, variance + tolerance));

		float mean = avgZ;
		float d = lightSpaceDepth - mean;
		float p_max = variance / (variance + d*d);


		return max(p_max, float(lightSpaceDepth <= avgZ));
	}
}

#line 644 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float
ChebyshevUpperBound(vec2 Moments, float t, float tolerance)
{
#line 647 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
if (t <= Moments.x) return 1.0f;


	float Variance = Moments.y - (Moments.x*Moments.x);
	Variance = max(Variance, tolerance);


	float d = t - Moments.x;
	float p_max = Variance / (Variance + d*d);

	return p_max;
}

#line 664 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float
ExponentialShadowSample(float mapDepth, float depth, float bias)
{
#line 666 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float receiverDepth = DepthScaling * depth - bias;
    float occluderReceiverDistance = mapDepth - receiverDepth;
	float occlusion = clamp(exp(DarkeningFactor * occluderReceiverDistance), 0.0f, 1.0f);

    return occlusion;
}

#line 47 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec4
ConvertViewRayToWorldPos(vec3 viewRay, float length, vec3 cameraPosition)
{
#line 49 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
return vec4(cameraPosition + viewRay * length, 1);
}

#line 57 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
void
CSMConvert(in vec4 worldPosition, out vec4 texShadow)
{
#line 60 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
texShadow = CSMShadowMatrix * worldPosition;
}

#line 84 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
void
CalculateBlendAmountForMap(in vec4 texCoord, out float blendBandLocation, out float blendAmount)
{
#line 87 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec2 distanceToOne = vec2(1.0f - texCoord.x, 1.0f - texCoord.y);
    blendBandLocation = min(texCoord.x, texCoord.y);
    float blendBandLocation2 = min(distanceToOne.x, distanceToOne.y);
    blendBandLocation = min(blendBandLocation, blendBandLocation2);
    blendAmount = blendBandLocation / CascadeBlendArea;
}

#line 101 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
float
CSMPS(in vec4 TexShadow, in uint Texture)
{
#line 107 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec4 texCoordShadow = vec4(0.0f);
	bool cascadeFound = false;
	float bias = GlobalLightShadowBias;

    TexShadow = TexShadow / TexShadow.wwww;

	vec3 shadowPosDDX = dFdx(TexShadow.xyz);
	vec3 shadowPosDDY = dFdy(TexShadow.xyz);

	int cascadeIndex;
	for( cascadeIndex = 0; cascadeIndex < 4; ++cascadeIndex)
	{
		texCoordShadow = TexShadow * CascadeScale[cascadeIndex];
		texCoordShadow += CascadeOffset[cascadeIndex];

		if ( min( texCoordShadow.x, texCoordShadow.y ) > MinBorderPadding
		  && max( texCoordShadow.x, texCoordShadow.y ) < MaxBorderPadding )
		{
			cascadeFound = true;
			break;
		}
	}

	shadowPosDDX *= CascadeScale[cascadeIndex].xyz;
	shadowPosDDX += CascadeOffset[cascadeIndex].xyz;
	shadowPosDDY *= CascadeScale[cascadeIndex].xyz;
	shadowPosDDY += CascadeOffset[cascadeIndex].xyz;

	float blendAmount = 0;
	float blendBandLocation = 0;
	CalculateBlendAmountForMap ( texCoordShadow, blendBandLocation, blendAmount );
                                                        
	if (!cascadeFound)
	{
		return 1.0f;
	}


	vec2 texCoord = texCoordShadow.xy;
	float depth = texCoordShadow.z;

	vec2 mapDepth = textureGrad(sampler2DArray(Textures2DArray[Texture], CSMTextureSampler), vec3(texCoord, cascadeIndex), shadowPosDDX.xy, shadowPosDDY.xy).rg;
	float occlusion = ChebyshevUpperBound(mapDepth, depth, 0.0000001f);

	int nextCascade = cascadeIndex + 1;
	float occlusionBlend = 1.0f;
	if (blendBandLocation < CascadeBlendArea)
	{
		if (nextCascade < 4)
		{
			texCoordShadow = TexShadow * CascadeScale[nextCascade];
			texCoordShadow += CascadeOffset[nextCascade];

			texCoord = texCoordShadow.xy;
			depth = texCoordShadow.z;

			mapDepth = textureGrad(sampler2DArray(Textures2DArray[Texture], CSMTextureSampler), vec3(texCoord, nextCascade), shadowPosDDX.xy, shadowPosDDY.xy).rg;
			occlusionBlend = ChebyshevUpperBound(mapDepth, depth, 0.0000001f);
		}


		occlusion = mix(occlusionBlend,occlusion,blendAmount);
	}
	return occlusion;
}

#line 184 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
float
SampleShadowCascade(vec4 position, vec3 ddx, vec3 ddy, uint cascadeIndex)
{
#line 186 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec3 shadowPosition = position.xyz;
	shadowPosition += CascadeOffset[cascadeIndex].xyz;
	shadowPosition *= CascadeScale[cascadeIndex].xyz;
	vec3 shadowPosDX = ddx * CascadeScale[cascadeIndex].xyz;
	vec3 shadowPosDY = ddy * CascadeScale[cascadeIndex].xyz;

	float lightDepth = shadowPosition.z;
	const float bias = GlobalLightShadowBias;
	lightDepth -= bias;
	vec2 samp = textureLod(sampler2DArray(Textures2DArray[GlobalLightShadowBuffer], CSMTextureSampler), vec3(shadowPosition.xy, cascadeIndex), 0).rg;

	return ChebyshevUpperBound(samp, lightDepth, 0.0001f);
}

#line 209 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
float
CSMPS2(in float Depth, in vec4 PositionShadowSpace, in float NL, in vec3 Normal, out vec4 Debug)
{
#line 211 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
int cascadeIndex = 4;
	for (int i = 4 - 1; i >= 0; --i)
	{
		if (Depth < CascadeDistances[i])
			cascadeIndex = i;
	}


	if (cascadeIndex == 4)
	{
		Debug = vec4(0,0,0,0);
		return 1.0f;
	}
	else
	{
		Debug = DebugColors[cascadeIndex];
	}

	vec4 shadowPosition = PositionShadowSpace;

	vec3 shadowPosDDX = dFdx(shadowPosition.xyz);
	vec3 shadowPosDDY = dFdy(shadowPosition.xyz);

	float shadowVisibility = SampleShadowCascade(shadowPosition, shadowPosDDX, shadowPosDDY, cascadeIndex);

	return shadowVisibility;
}

#line 16 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
vec3
perez(float cosTheta, float gamma, float cosGamma, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E)
{
#line 18 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
return (1 + A * exp(B / (cosTheta + (0.0001f)))) * (1 + C * exp(D * gamma) + E * cosGamma * cosGamma);
}

#line 24 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
vec3
YxyToXYZ(in vec3 Yxy)
{
#line 26 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
float Y = Yxy.r;
	float x = Yxy.g;
	float y = Yxy.b;

	float X = x * ( Y / y );
	float Z = ( 1.0 - x - y ) * ( Y / y );

	return vec3(X,Y,Z);
}

#line 39 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
vec3
XYZToRGB(in vec3 XYZ)
{
#line 42 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
mat3 M = mat3
	(
		 2.3706743, -0.9000405, -0.4706338,
		-0.5138850, 1.4253036, 0.0885814,
 		 0.0052982, -0.0146949, 1.0093968
	);

	return XYZ * M;
}

#line 59 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
vec3
Preetham(vec3 sphereDir, vec3 lightDir, vec4 A, vec4 B, vec4 C, vec4 D, vec4 E, vec4 Z)
{
#line 62 "G:/nebula/nebula/work/shaders/vk/lib/preetham.fxh"
float cosThetaSun = clamp(dot(lightDir, vec3(0, 1, 0)), 0.0f, 1.0f);
	float cosTheta = clamp(dot(sphereDir, vec3(0, 1, 0)), 0.0f, 1.0f);
	float cosGamma = clamp(dot(sphereDir, lightDir.xyz), 0.0f, 1.0f);
	float thetaSun = acos(cosThetaSun);
	float gamma = acos(cosGamma);
	vec3 r_xyY = Z.xyz * (perez(cosTheta, gamma, cosGamma, A.xyz, B.xyz, C.xyz, D.xyz, E.xyz));
	vec3 zeroThetaS = perez(0.0, thetaSun, cosThetaSun, A.xyz, B.xyz, C.xyz, D.xyz, E.xyz);

	vec3 r_XYZ = YxyToXYZ(r_xyY / zeroThetaS);
	vec3 ret = XYZToRGB(r_XYZ);
	return ret * 1/3.14159265;
}

#line 26 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
RimLightIntensity(vec3 worldNormal, vec3 worldEyeVec)
{
#line 28 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float rimIntensity = pow(abs(1.0f - abs(dot(worldNormal, worldEyeVec))), RimPower);
    rimIntensity *= RimIntensity;
    return rimIntensity;
}

#line 38 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec3
FresnelSchlick(vec3 spec, float dotprod)
{
#line 40 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float base = 1.0 - clamp(dotprod, 0.0f, 1.0f);
	float exponent = pow(base, 5);
	return spec + (1 - spec) * exponent;
}

#line 50 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec3
FresnelSchlickGloss(vec3 spec, float dotprod, float roughness)
{
#line 52 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float base = 1.0 - clamp(dotprod, 0.0f, 1.0f);
	float exponent = pow(base, 5);
	return spec + (max(vec3(1 - roughness), spec) - spec) * exponent;
}

#line 63 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
NormalDistributionGGX(in float NdotH, in float roughness)
{
#line 65 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float a = pow(roughness, 4);
	float NdotH2 = NdotH * NdotH;

	float denom = (NdotH2 * (a - 1.0f) + 1.0f);
	denom = 3.14159265 * denom * denom;

	return (a / (denom + 0.00001f));
}

#line 80 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
GeometrySchlickGGX(in float NdotV, in float k)
{
#line 82 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float denom = fma(NdotV,1.0f - k,k);
	return NdotV / denom;
}

#line 90 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float
GeometrySmith(in float NdotV, in float NdotL, in float roughness)
{
#line 92 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float r = roughness + 1.0f;
	float k = (r*r) * 0.125f;
	float ggxNV = GeometrySchlickGGX(NdotV, k);
	float ggxNL = GeometrySchlickGGX(NdotL, k);
	return ggxNV * ggxNL;
}

#line 104 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
void
CalculateF0(in vec3 color, in float metallic, inout vec3 F0)
{
#line 109 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
F0 = mix(F0, color.rgb, metallic);
}

#line 125 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
void
CalculateBRDF(float NdotH, float NdotL, float NdotV, float cosTheta, float roughness, vec3 F0, out vec3 F, out vec3 brdf)
{
#line 129 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
F = FresnelSchlickGloss(F0, max(cosTheta, 0.0), roughness);

    float NDF = NormalDistributionGGX(NdotH, roughness);
    float G = GeometrySmith(NdotV, NdotL, roughness);


    vec3 nominator = NDF * G * F;
    float denominator = 4 * NdotV * NdotL + 0.001f;
    brdf = nominator / denominator;
}

#line 152 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
void
BRDFLighting(float NH, float NL, float NV, float HL, float specPower, vec3 specColor, out vec3 spec)
{
#line 154 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
float normalizationTerm = (specPower + 2.0f) / 8.0f;
	float blinnPhong = pow(NH, specPower);
	float specularTerm = blinnPhong;
	float cosineTerm = NL;
	vec3 fresnelTerm = FresnelSchlick(specColor, HL);
	float alpha = 1.0f / ( sqrt ( 3.14159265/4.0f * specPower + 3.14159265/2.0f) );
	float visibilityTerm = (NL * (1.0f - alpha) + alpha ) * (NV * ( 1.0f - alpha ) + alpha );
	visibilityTerm = 1.0f / visibilityTerm;
	spec = specularTerm * cosineTerm * fresnelTerm * visibilityTerm;
}

#line 171 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec4
ConvertOSM(in vec4 material)
{
#line 173 "G:/nebula/nebula/work/shaders/vk/lib/pbr.fxh"
vec4 ret;
	ret[0] = material.b;
	ret[1] = 1 - material.g;
	ret[2] = 1 - material.r;
	ret[3] = material.a;
	return ret;
}

#line 164 "G:/nebula/nebula/work/shaders/vk/lights.fx"
float
GetInvertedOcclusionSpotLight(float receiverDepthInLightSpace, vec2 lightSpaceUv, uint Texture)
{
#line 168 "G:/nebula/nebula/work/shaders/vk/lights.fx"
vec2 shadowUv = lightSpaceUv;
    shadowUv.xy *= ShadowOffsetScale.zw;
    shadowUv.xy += ShadowOffsetScale.xy;


    vec2 shadowSample = texture(sampler2D(Textures2D[Texture], SpotlightTextureSampler), shadowUv).rg;


    return ChebyshevUpperBound(shadowSample, receiverDepthInLightSpace, 0.000001f);
}

#line 281 "G:/nebula/nebula/work/shaders/vk/lights.fx"
float
GetInvertedOcclusionPointLight(float receiverDepthInLightSpace, vec3 lightSpaceUv, uint Texture)
{
#line 285 "G:/nebula/nebula/work/shaders/vk/lights.fx"
vec3 shadowUv = lightSpaceUv;


    vec2 shadowSample = texture(samplerCube(TexturesCube[Texture], PointLightTextureSampler), shadowUv).rg;


    return ChebyshevUpperBound(shadowSample, receiverDepthInLightSpace, 0.00000001f);
}

	layout(location = 0) out vec4 Color;
#line 96 "G:/nebula/nebula/work/shaders/vk/lights.fx"
void
main()
{
#line 98 "G:/nebula/nebula/work/shaders/vk/lights.fx"
vec3 rawNormal = subpassLoad(InputAttachment1).xyz;
    vec4 albedoColor = subpassLoad(InputAttachment0);
    if (rawNormal.z == -1.0f) { Color = albedoColor; return; };

    vec3 normal = rawNormal;
    float Depth = subpassLoad(DepthAttachment).r;

    float NL = clamp(dot(GlobalLightDir.xyz, normal), 0.0f, 1.0f);
    if (NL <= 0) { Color = albedoColor; return; };
    vec4 worldPos = PixelToWorld((gl_FragCoord.xy + vec2(0.5f, 0.5f)) * RenderTargetDimensions[0].zw, Depth);
    vec3 viewVec = normalize(EyePos.xyz - worldPos.xyz);

    float shadowFactor = 1.0f;
    if (((GlobalLightFlags & USE_SHADOW_BITFLAG) == USE_SHADOW_BITFLAG))
    {

        vec4 shadowPos = CSMShadowMatrix * worldPos;
        shadowFactor = CSMPS(shadowPos, GlobalLightShadowBuffer);

        shadowFactor = mix(1.0f,shadowFactor,GlobalLightShadowIntensity);
    }

    vec3 diff = GlobalAmbientLightColor.xyz;
    diff += GlobalLightColor.xyz * clamp(NL, 0.0f, 1.0f);


    vec4 specColor = subpassLoad(InputAttachment2);
    float specPower = exp2(13 * specColor.a + 1);

    vec3 H = normalize(GlobalLightDir.xyz + viewVec);
    float NH = clamp(dot(normal, H), 0.0f, 1.0f);
    float NV = clamp(dot(normal, viewVec), 0.0f, 1.0f);
    float HL = clamp(dot(H, GlobalLightDir.xyz), 0.0f, 1.0f);
    vec3 spec;
    BRDFLighting(NH, NL, NV, HL, specPower, specColor.rgb, spec);


    vec3 skyLight = Preetham(normal, GlobalLightDir.xyz, A, B, C, D, E, Z) * GlobalLightColor.xyz;
    diff += skyLight;

    vec3 final = (albedoColor.rgb + spec) * diff;

    Color = vec4(final * shadowFactor, 1);
}
