#version 450 core
#define gl_InstanceID gl_InstanceIndex
#define gl_VertexID gl_VertexIndex
#extension GL_GOOGLE_cpp_style_line_directive : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#define SPIRV
#define FRAGMENT_SHADER

layout(set=0, binding=5) uniform sampler Basic2DSampler;
layout(set=0, binding=6) uniform sampler PosteffectSampler;
layout(set=0, binding=7) uniform sampler PosteffectUpscaleSampler;
layout(set=3, binding=0) uniform sampler GeometryTextureSampler;
layout(set=3, binding=1) uniform sampler MaterialSampler;
layout(set=3, binding=2) uniform sampler NormalSampler;
layout(set=3, binding=3) uniform sampler CubeSampler;
layout(set=3, binding=4) uniform sampler EnvironmentSampler;
layout(set=3, binding=5) uniform sampler ShadowSampler;
layout(set=3, binding=6) uniform sampler CSMTextureSampler;
layout(set=3, binding=7) uniform sampler ScreenSampler;
layout(set=3, binding=8) uniform sampler WaveSampler;
layout(set=0, binding=0) uniform 	texture2D Textures2D[2048];
layout(set=0, binding=1) uniform 	texture2DMS Textures2DMS[64];
layout(set=0, binding=2) uniform 	textureCube TexturesCube[128];
layout(set=0, binding=3) uniform 	texture3D Textures3D[128];
layout(set=0, binding=4) uniform 	texture2DArray Textures2DArray[8];
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=0) uniform 	subpassInput InputAttachment0;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=1) uniform 	subpassInput InputAttachment1;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=2) uniform 	subpassInput InputAttachment2;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=3) uniform 	subpassInput InputAttachment3;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=4) uniform 	subpassInput InputAttachment4;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=5) uniform 	subpassInput InputAttachment5;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=6) uniform 	subpassInput InputAttachment6;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=7) uniform 	subpassInput InputAttachment7;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=8) uniform 	subpassInput InputAttachment8;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=9) uniform 	subpassInput InputAttachment9;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=10) uniform 	subpassInput InputAttachment10;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=11) uniform 	subpassInput InputAttachment11;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=12) uniform 	subpassInput InputAttachment12;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=13) uniform 	subpassInput InputAttachment13;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=14) uniform 	subpassInput InputAttachment14;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=15) uniform 	subpassInput InputAttachment15;
#endif //FRAGMENT_SHADER
#ifdef FRAGMENT_SHADER
layout(input_attachment_index=0, set=2, binding=16) uniform 	subpassInput DepthAttachment;
#endif //FRAGMENT_SHADER
layout(std140, set=0, binding=8) uniform PerTickParams
{
/* Offset:0 */	vec4 WindDirection;
/* Offset:16 */	float WindWaveSize;
/* Offset:20 */	float WindSpeed;
/* Offset:24 */	float WindIntensity;
/* Offset:28 */	float WindForce;
/* Offset:32 */	float Saturation;
/* Offset:36 */	float MaxLuminance;
/* Offset:40 */	float FadeValue;
/* Offset:44 */	uint UseDof;
/* Offset:48 */	vec4 Balance;
/* Offset:64 */	vec3 DoFDistances;
/* Offset:76 */	float HDRBrightPassThreshold;
/* Offset:80 */	vec4 HDRBloomColor;
/* Offset:96 */	vec4 FogDistances;
/* Offset:112 */	vec4 FogColor;
/* Offset:128 */	uint GlobalLightFlags;
/* Offset:132 */	float GlobalLightShadowIntensity;
/* Offset:144 */	vec4 GlobalLightDirWorldspace;
/* Offset:160 */	vec4 GlobalLightDir;
/* Offset:176 */	vec4 GlobalLightColor;
/* Offset:192 */	vec4 GlobalBackLightColor;
/* Offset:208 */	vec4 GlobalAmbientLightColor;
/* Offset:224 */layout(column_major) 	mat4x4 CSMShadowMatrix;
/* Offset:288 */	float GlobalBackLightOffset;
/* Offset:292 */	uint GlobalLightShadowBuffer;
/* Offset:296 */	int NumEnvMips;
/* Offset:300 */	uint EnvironmentMap;
/* Offset:304 */	vec4 A;
/* Offset:320 */	vec4 B;
/* Offset:336 */	vec4 C;
/* Offset:352 */	vec4 D;
/* Offset:368 */	vec4 E;
/* Offset:384 */	vec4 Z;
/* Offset:400 */	float RayleighFactor;
/* Offset:404 */	float RayleighZenithLength;
/* Offset:408 */	float RefractiveIndex;
/* Offset:412 */	float DepolarizationFactor;
/* Offset:416 */	float Molecules;
/* Offset:420 */	float MieV;
/* Offset:424 */	float MieCoefficient;
/* Offset:428 */	float MieDirectionalG;
/* Offset:432 */	float MieZenithLength;
/* Offset:436 */	float Turbidity;
/* Offset:440 */	float SunIntensityFactor;
/* Offset:444 */	float SunIntensityFalloff;
/* Offset:448 */	float SunDiscSize;
/* Offset:464 */	vec3 MieKCoefficient;
/* Offset:480 */	vec3 PrimaryColors;
/* Offset:492 */	float TonemapWeight;
/* Offset:496 */	float Lum;
/* Offset:512 */	vec4 CascadeOffset[4];
/* Offset:576 */	vec4 CascadeScale[4];
/* Offset:640 */	vec4 CascadeDistances;
/* Offset:656 */	float MinBorderPadding;
/* Offset:660 */	float MaxBorderPadding;
/* Offset:664 */	float ShadowPartitionSize;
/* Offset:668 */	float GlobalLightShadowBias;
/* Offset:672 */	uint NormalBuffer;
/* Offset:676 */	uint DepthBuffer;
/* Offset:680 */	uint SpecularBuffer;
/* Offset:684 */	uint AlbedoBuffer;
/* Offset:688 */	uint EmissiveBuffer;
/* Offset:692 */	uint LightBuffer;
/* Offset:696 */	uint IrradianceMap;
/* Offset:700 */	uint DepthBufferCopy;
};

layout(std140, set=1, binding=0) uniform FrameBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 View;
/* Offset:64 */layout(column_major) 	mat4x4 InvView;
/* Offset:128 */layout(column_major) 	mat4x4 ViewProjection;
/* Offset:192 */layout(column_major) 	mat4x4 Projection;
/* Offset:256 */layout(column_major) 	mat4x4 InvProjection;
/* Offset:320 */layout(column_major) 	mat4x4 InvViewProjection;
/* Offset:384 */	vec4 EyePos;
/* Offset:400 */	vec4 FocalLengthNearFar;
/* Offset:416 */	vec4 TimeAndRandom;
};

layout(std140, set=1, binding=1) uniform ShadowMatrixBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 CSMViewMatrix[4];
/* Offset:256 */layout(column_major) 	mat4x4 LightViewMatrix[16];
};

layout(std140, set=2, binding=17) uniform PassBlock
{
/* Offset:0 */	vec4 RenderTargetDimensions[16];
};

layout(std140, set=6, binding=0) uniform ObjectBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 Model;
/* Offset:64 */layout(column_major) 	mat4x4 InvModel;
/* Offset:128 */	int ObjectId;
/* Offset:132 */	float DitherFactor;
};

layout(std140, set=6, binding=1) uniform InstancingBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 ModelArray[256];
/* Offset:16384 */layout(column_major) 	mat4x4 ModelViewArray[256];
/* Offset:32768 */layout(column_major) 	mat4x4 ModelViewProjectionArray[256];
/* Offset:49152 */	int IdArray[256];
};

layout(std140, set=6, binding=2) uniform JointBlock
{
/* Offset:0 */layout(column_major) 	mat4x4 JointPalette[256];
};

layout(std140, set=3, binding=10) uniform DefaultSamplers
{
/* Offset:0 */	uint AlbedoMap;
/* Offset:4 */	uint DisplacementMap;
/* Offset:8 */	uint ParameterMap;
/* Offset:12 */	uint NormalMap;
};

layout(std140, set=3, binding=11) uniform TessellationParams
{
/* Offset:0 */	float TessellationFactor;
/* Offset:4 */	float MaxDistance;
/* Offset:8 */	float MinDistance;
/* Offset:12 */	float HeightScale;
/* Offset:16 */	float SceneScale;
};

layout(std140, set=3, binding=12) uniform WaterBlock
{
/* Offset:0 */	float DynamicTessellationFactor;
/* Offset:4 */	float WaveSpeed;
/* Offset:16 */	vec4 WaterColor;
/* Offset:32 */	vec4 WaterSpecular;
/* Offset:48 */	vec4 WaterScatterColor;
/* Offset:64 */	vec2 WaterColorIntensity;
/* Offset:72 */	float FogDistance;
/* Offset:80 */	vec4 FogBrightColor;
/* Offset:96 */	vec4 FogDarkColor;
/* Offset:112 */	float FogDensity;
/* Offset:120 */	vec2 TileSize;
/* Offset:128 */	vec2 WaveScale;
/* Offset:136 */	vec2 WaveMicroScale;
/* Offset:144 */	float WaveHeight;
/* Offset:152 */	vec2 DepthMapPixelSize;
/* Offset:160 */	vec2 HeightMapPixelSize;
/* Offset:168 */	vec2 ColorMapPixelSize;
/* Offset:176 */	uint ColorMap;
/* Offset:180 */	uint DepthMap;
/* Offset:184 */	uint WaveMap;
/* Offset:188 */	uint HeightMap;
};

const int TICK_GROUP = int(0);
const int FRAME_GROUP = int(1);
const int PASS_GROUP = int(2);
const int BATCH_GROUP = int(3);
const int INSTANCE_GROUP = int(4);
const int SYSTEM_GROUP = int(5);
const int DYNAMIC_OFFSET_GROUP = int(6);
const float depthScale = float(100);
const float MiddleGrey = float(0.5);
const float Key = float(0.300000012);
const vec4 Luminance = vec4(0.212599993, 0.715200007, 0.0722000003, 0);
const int m = int(1540483477);
const float F3 = float(0.333333313);
const float G3 = float(0.166666701);
const mat3x3 rot1 = mat3x3(-0.370000005, 0.360000014, 0.850000024, -0.140000001, -0.930000007, 0.340000004, 0.920000017, 0.00999999978, 0.400000006);
const mat3x3 rot2 = mat3x3(-0.550000012, -0.389999986, 0.74000001, 0.330000013, -0.910000026, -0.239999995, 0.769999981, 0.119999997, 0.629999995);
const mat3x3 rot3 = mat3x3(-0.709999979, 0.519999981, -0.469999999, -0.0799999982, -0.720000029, -0.680000007, -0.699999988, -0.449999988, 0.560000002);
const int MAX_2D_TEXTURES = int(2048);
const int MAX_2D_MS_TEXTURES = int(64);
const int MAX_2D_ARRAY_TEXTURES = int(8);
const int MAX_CUBE_TEXTURES = int(128);
const int MAX_3D_TEXTURES = int(128);
const int SHADOW_CASTER_COUNT = int(16);
const int MAX_INSTANCING_BATCH_SIZE = int(256);
const float DepthScaling = float(5);
const float DarkeningFactor = float(1);
const float ShadowConstant = float(100);
const int SplitsPerRow = int(1);
const int SplitsPerColumn = int(1);
const vec4 DebugColors[8] = vec4[8](vec4(1.5, 0, 0, 1), vec4(0, 1.5, 0, 1), vec4(0, 0, 5.5, 1), vec4(1.5, 0, 5.5, 1), vec4(1.5, 1.5, 0, 1), vec4(1, 1, 1, 1), vec4(0, 1, 5.5, 1), vec4(0.5, 3.5, 0.75, 1));
const float CascadeBlendArea = float(0.200000003);
const vec2 sampleOffsets[12] = vec2[12](vec2(-0.326000005, -0.405999988), vec2(-0.839999974, -0.074000001), vec2(-0.69599998, 0.456999987), vec2(-0.202999994, 0.620999992), vec2(0.962000012, -0.194999993), vec2(0.47299999, -0.479999989), vec2(0.518999994, 0.76700002), vec2(0.185000002, -0.893000007), vec2(0.507000029, 0.064000003), vec2(0.896000028, 0.412), vec2(-0.321999997, -0.933000028), vec2(-0.791999996, -0.59799999));
#line 67 "G:/nebula/nebula/work/shaders/vk/lib/std.fxh"
void
sincos(float angle, out float sinus, out float cosinus)
{
#line 69 "G:/nebula/nebula/work/shaders/vk/lib/std.fxh"
sinus = sin(angle);
	cosinus = cos(angle);
}

#line 19 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
Encode2(vec2 inVals)
{
#line 21 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4(inVals.x, fract(inVals.x * 256.0), inVals.y, fract(inVals.y * 256.0));
}

#line 29 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
Decode2(vec4 inVals)
{
#line 31 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec2(inVals.x + (inVals.y / 256.0), inVals.z + (inVals.w / 256.0));
}

#line 39 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
UnpackNormal(vec3 packedDataNormal)
{
#line 41 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (packedDataNormal * 2.0) - 1.0;
}

#line 49 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
UnpackNormal4(vec4 packedDataNormal)
{
#line 51 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4((packedDataNormal.xyz * 2.0) - 1.0, 1.0f);
}

#line 59 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
UnpackUv(vec2 packedDataUv)
{
#line 61 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (packedDataUv / 8192.0);
}

#line 70 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
UnpackWeights(vec4 weights)
{
#line 72 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (weights / dot(weights, vec4(1.0, 1.0, 1.0, 1.0)));
}

#line 135 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
ToneMap(vec4 vColor, vec4 lumAvg, float maxLum)
{
#line 146 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float L = dot(vColor, Luminance);
	float Lp = L * Key / lumAvg.x;
	float nL = (Lp * (1.0f + Lp / (MiddleGrey))) / (1.0f + Lp);




	vec3 color = vColor.rgb * (nL / L) * maxLum;



	return vec4(color, 1.0f);
}

#line 165 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
linstep(float min, float max, float v)
{
#line 167 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return clamp((v - min) / (max - min), 0.0f, 1.0f);
}

#line 179 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
void
pack_u16(in float depth, out float byte_a, out float byte_b)
{
#line 181 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float tmp = depth / 256.0f;
    byte_a = floor(tmp) / 256.0f;
    byte_b = fract(tmp);
}

#line 191 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
unpack_u16(in float byte_a, in float byte_b)
{
#line 193 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return ((byte_a * 256.0f) * 256.0f) + (byte_b * 256.0f);
}

#line 203 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
void
pack_16bit_normal_component(in float n, out float byte_a, out float byte_b)
{
#line 205 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
n = ((n * 0.5f) + 0.5f) * 65535.0f;

    pack_u16(n, byte_a, byte_b);
}

#line 214 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
unpack_16bit_normal_component(in float byte_a, in float byte_b)
{
#line 216 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return ((unpack_u16(byte_a, byte_b) / 65535.0f) - 0.5f) * 2.0f;
}

#line 223 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
pack_normalxy_into_rgba8(in float normal_x, in float normal_y)
{
#line 225 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 ret;
    pack_16bit_normal_component(normal_x, ret.x, ret.y);
    pack_16bit_normal_component(normal_y, ret.z, ret.w);
    return ret;
}

#line 235 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
unpack_normalxy_from_rgba8(in vec4 packedData)
{
#line 237 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4( unpack_16bit_normal_component(packedData.x, packedData.y),
                    unpack_16bit_normal_component(packedData.z, packedData.w),
                    0.0f,
                    0.0f);
}

#line 249 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PackViewSpaceNormal(in vec3 viewSpaceNormal)
{
#line 252 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
viewSpaceNormal = normalize(viewSpaceNormal);



    const float scale = 1.7777f;
    vec2 enc = viewSpaceNormal.xy / (viewSpaceNormal.z+1.0f);
    enc /= scale;
    enc = enc * 0.5f + 0.5f;


    vec4 normal = pack_normalxy_into_rgba8(enc.x, enc.y);
    return normal;
}

#line 271 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
UnpackViewSpaceNormal(in vec4 packedDataValue)
{
#line 274 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 unpackedData = unpack_normalxy_from_rgba8(packedDataValue);


    const float scale = 1.7777f;
    vec3 nn = unpackedData.xyz * vec3(2.0f * scale, 2.0f * scale, 0.0f) + vec3(-scale, -scale, 1.0f);
    float g = 2.0f / dot(nn.xyz, nn.xyz);
    vec3 outViewSpaceNormal;
    outViewSpaceNormal.xy = g * nn.xy;
    outViewSpaceNormal.z = g - 1.0f;
    return outViewSpaceNormal;
}

#line 295 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PackObjectDepth(in float ObjectId, in float NormalGroupId, in float depth)
{
#line 297 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 packedData;
    packedData.x = ObjectId;
    packedData.y = NormalGroupId;


    depth = depth * depthScale;
    pack_u16(depth, packedData.z, packedData.w);
    return packedData;
}

#line 316 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
UnpackDepth(in vec4 packedData)
{
#line 318 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return unpack_u16(packedData.z, packedData.w) / depthScale;
}

#line 332 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
psLightMaterial(in vec4 lightValues, in vec4 diffColor, in vec3 emsvColor, in float emsvIntensity, in vec3 specColor, in float specIntensity)
{
#line 334 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
lightValues = lightValues;
    vec4 color = diffColor;

    color.xyz *= lightValues.xyz;
    color.xyz += emsvColor * emsvIntensity;

    vec3 normedColor = normalize(lightValues.xyz);
    float maxColor = max(max(normedColor.x, normedColor.y), normedColor.z);
    normedColor /= maxColor;
    float spec = lightValues.w;
    color.xyz += specColor * specIntensity * spec * normedColor;

    return color;
}

#line 358 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
log_conv(float x0, float x, float y0, float y)
{
#line 360 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (x + log(x0 + (y0 * exp(y - x))));
}

#line 368 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetPixelSize(in sampler2D tex)
{
#line 370 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 size = textureSize(tex, 0);
	size = vec2(1.0f) / size;
	return size;
}

#line 380 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetScaledUVs(in vec2 uvs, in sampler2D tex, in vec2 dimensions)
{
#line 382 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 texSize = textureSize(tex, 0);
	uvs = uvs * (dimensions / texSize);
	return uvs;
}

#line 392 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetUV(in ivec2 pixel, in sampler2D tex)
{
#line 394 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2 size = textureSize(tex, 0);
	size = pixel / size;
	return size;
}

#line 404 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2
GetPixel(in vec2 uv, in sampler2D tex)
{
#line 406 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2 size = textureSize(tex, 0);
	size = ivec2(uv * size);
	return size;
}

#line 416 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
GetTextureRatio(in sampler2D tex, vec2 pixelSize)
{
#line 418 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
ivec2 size = textureSize(tex, 0);
	vec2 currentTextureSize = vec2(1.0f) / size;
	return size / currentTextureSize;
}

#line 428 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
FlipY(vec2 uv)
{
#line 430 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec2(uv.x, 1.0f - uv.y);
}

#line 437 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
LinearizeDepth(float depth)
{
#line 439 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return (FocalLengthNearFar.z * FocalLengthNearFar.w) / (depth * (FocalLengthNearFar.z - FocalLengthNearFar.w) + FocalLengthNearFar.w);
}

#line 446 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
DelinearizeDepth(float depth)
{
#line 448 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return -((FocalLengthNearFar.z + FocalLengthNearFar.w) * depth - (2 * FocalLengthNearFar.z)) / ((FocalLengthNearFar.z - FocalLengthNearFar.w) * depth);
}

#line 456 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec2
PixelToNormalized(in vec2 screenCoord, in vec2 pixelSize)
{
#line 458 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return screenCoord.xy * pixelSize.xy;
}

#line 466 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToProjection(vec2 screenCoord, float depth)
{
#line 469 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return vec4(screenCoord * 2.0f - 1.0f, depth, 1.0f);
}

#line 477 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToView(vec2 screenCoord, float depth)
{
#line 479 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 projectionSpace = PixelToProjection(screenCoord, depth);
    vec4 viewSpace = InvProjection * projectionSpace;
    viewSpace /= viewSpace.w;
	return viewSpace;
}

#line 490 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
PixelToWorld(vec2 screenCoord, float depth)
{
#line 492 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4 viewSpace = PixelToView(screenCoord, depth);
	return InvView * viewSpace;
}

#line 501 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec4
ViewToWorld(const vec4 viewSpace)
{
#line 503 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return InvView * viewSpace;
}

#line 511 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
GetPosition(mat4x4 transform)
{
#line 513 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return transform[2].xyz;
}

#line 522 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uvec3
Unpack1DTo3D(uint index1D, uint width, uint height)
{
#line 524 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uint i = index1D % width;
    uint j = index1D % (width * height) / width;
    uint k = index1D / (width * height);

    return uvec3(i, j, k);
}

#line 536 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
uint
Pack3DTo1D(uvec3 index3D, uint width, uint height)
{
#line 538 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return index3D.x + (width * (index3D.y + height * index3D.z));
}

#line 544 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
bool
IntersectLineWithPlane(vec3 lineStart, vec3 lineEnd, vec4 plane, out vec3 intersect)
{
#line 546 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 ab = lineEnd - lineStart;
    float t = (plane.w - dot(plane.xyz, lineStart)) / dot(plane.xyz, ab);
    bool ret = (t >= 0.0f && t <= 1.0f);
    intersect = vec3(0, 0, 0);
    if (ret)
    {
        intersect = lineStart + t * ab;
    }

    return ret;
}

#line 569 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
hash11(float p)
{
#line 571 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

#line 580 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
hash12(vec2 p)
{
#line 582 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

#line 591 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
hash32(vec2 p)
{
#line 593 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));
    p3 += dot(p3, p3.yxz + 19.19);
    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
}

#line 603 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
murmur(int k)
{
#line 605 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
int h = k ^ 1;

    k *= m;
    k ^= k >> 24;
    k *= m;

    h *= m;
    h ^= k;

    return float(h);
}

#line 622 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3
random3(vec3 c)
{
#line 624 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 r;
    float c1 = dot(c, vec3(17.0f, 59.4f, 15.0f));
    r.x = fract(murmur(int(c.x * c1)) / 512.0f);
    r.y = fract(murmur(int(c.y * c1)) / 512.0f);
    r.z = fract(murmur(int(c.z * c1)) / 512.0f);
    return r - 0.5f;
}

#line 641 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
simplex3D(vec3 p)
{
#line 648 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
vec3 s = floor(p + dot(p, vec3(F3)));
    vec3 x = p - s + dot(s, vec3(G3));


    vec3 e = step(vec3(0.0f), x - x.yzx);
    vec3 i1 = e * (1.0f - e.zxy);
    vec3 i2 = 1.0f - e.zxy * (1.0f - e);


    vec3 x1 = x - i1 + G3;
    vec3 x2 = x - i2 + 2.0f * G3;
    vec3 x3 = x - 1.0f + 3.0f * G3;


    vec4 w, d;


    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);


    w = max(0.6f - w, 0.0f);


    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0f), x3);


    w *= w;
    w *= w;
    d *= w;


    return dot(d, vec4(52.0f));
}

#line 696 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
float
simplex3D_fractal(vec3 m)
{
#line 698 "G:/nebula/nebula/work/shaders/vk/lib/util.fxh"
return 0.5333333f * simplex3D(m * rot1)
        + 0.2666667f * simplex3D(2.0f * m * rot2)
        + 0.1333333f * simplex3D(4.0f * m * rot3)
        + 0.0666667f * simplex3D(8.0f * m);
}

#line 614 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float
Variance(vec2 shadowSample, float lightSpaceDepth, float tolerance)
{
#line 617 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float avgZ = shadowSample.x;
	float avgZ2 = shadowSample.y;


	if (lightSpaceDepth <= avgZ)
	{
		return 1.0f;
	}
	else
	{
		float variance = (avgZ2) - (avgZ * avgZ);
		variance = min(1.0f, max(0.0f, variance + tolerance));

		float mean = avgZ;
		float d = lightSpaceDepth - mean;
		float p_max = variance / (variance + d*d);


		return max(p_max, float(lightSpaceDepth <= avgZ));
	}
}

#line 644 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float
ChebyshevUpperBound(vec2 Moments, float t, float tolerance)
{
#line 647 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
if (t <= Moments.x) return 1.0f;


	float Variance = Moments.y - (Moments.x*Moments.x);
	Variance = max(Variance, tolerance);


	float d = t - Moments.x;
	float p_max = Variance / (Variance + d*d);

	return p_max;
}

#line 664 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float
ExponentialShadowSample(float mapDepth, float depth, float bias)
{
#line 666 "G:/nebula/nebula/work/shaders/vk/lib/shadowbase.fxh"
float receiverDepth = DepthScaling * depth - bias;
    float occluderReceiverDistance = mapDepth - receiverDepth;
	float occlusion = clamp(exp(DarkeningFactor * occluderReceiverDistance), 0.0f, 1.0f);

    return occlusion;
}

#line 47 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec4
ConvertViewRayToWorldPos(vec3 viewRay, float length, vec3 cameraPosition)
{
#line 49 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
return vec4(cameraPosition + viewRay * length, 1);
}

#line 57 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
void
CSMConvert(in vec4 worldPosition, out vec4 texShadow)
{
#line 60 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
texShadow = CSMShadowMatrix * worldPosition;
}

#line 84 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
void
CalculateBlendAmountForMap(in vec4 texCoord, out float blendBandLocation, out float blendAmount)
{
#line 87 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec2 distanceToOne = vec2(1.0f - texCoord.x, 1.0f - texCoord.y);
    blendBandLocation = min(texCoord.x, texCoord.y);
    float blendBandLocation2 = min(distanceToOne.x, distanceToOne.y);
    blendBandLocation = min(blendBandLocation, blendBandLocation2);
    blendAmount = blendBandLocation / CascadeBlendArea;
}

#line 101 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
float
CSMPS(in vec4 TexShadow, in uint Texture)
{
#line 107 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec4 texCoordShadow = vec4(0.0f);
	bool cascadeFound = false;
	float bias = GlobalLightShadowBias;

    TexShadow = TexShadow / TexShadow.wwww;

	vec3 shadowPosDDX = dFdx(TexShadow.xyz);
	vec3 shadowPosDDY = dFdy(TexShadow.xyz);

	int cascadeIndex;
	for( cascadeIndex = 0; cascadeIndex < 4; ++cascadeIndex)
	{
		texCoordShadow = TexShadow * CascadeScale[cascadeIndex];
		texCoordShadow += CascadeOffset[cascadeIndex];

		if ( min( texCoordShadow.x, texCoordShadow.y ) > MinBorderPadding
		  && max( texCoordShadow.x, texCoordShadow.y ) < MaxBorderPadding )
		{
			cascadeFound = true;
			break;
		}
	}

	shadowPosDDX *= CascadeScale[cascadeIndex].xyz;
	shadowPosDDX += CascadeOffset[cascadeIndex].xyz;
	shadowPosDDY *= CascadeScale[cascadeIndex].xyz;
	shadowPosDDY += CascadeOffset[cascadeIndex].xyz;

	float blendAmount = 0;
	float blendBandLocation = 0;
	CalculateBlendAmountForMap ( texCoordShadow, blendBandLocation, blendAmount );
                                                        
	if (!cascadeFound)
	{
		return 1.0f;
	}


	vec2 texCoord = texCoordShadow.xy;
	float depth = texCoordShadow.z;

	vec2 mapDepth = textureGrad(sampler2DArray(Textures2DArray[Texture], CSMTextureSampler), vec3(texCoord, cascadeIndex), shadowPosDDX.xy, shadowPosDDY.xy).rg;
	float occlusion = ChebyshevUpperBound(mapDepth, depth, 0.0000001f);

	int nextCascade = cascadeIndex + 1;
	float occlusionBlend = 1.0f;
	if (blendBandLocation < CascadeBlendArea)
	{
		if (nextCascade < 4)
		{
			texCoordShadow = TexShadow * CascadeScale[nextCascade];
			texCoordShadow += CascadeOffset[nextCascade];

			texCoord = texCoordShadow.xy;
			depth = texCoordShadow.z;

			mapDepth = textureGrad(sampler2DArray(Textures2DArray[Texture], CSMTextureSampler), vec3(texCoord, nextCascade), shadowPosDDX.xy, shadowPosDDY.xy).rg;
			occlusionBlend = ChebyshevUpperBound(mapDepth, depth, 0.0000001f);
		}


		occlusion = mix(occlusionBlend,occlusion,blendAmount);
	}
	return occlusion;
}

#line 184 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
float
SampleShadowCascade(vec4 position, vec3 ddx, vec3 ddy, uint cascadeIndex)
{
#line 186 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
vec3 shadowPosition = position.xyz;
	shadowPosition += CascadeOffset[cascadeIndex].xyz;
	shadowPosition *= CascadeScale[cascadeIndex].xyz;
	vec3 shadowPosDX = ddx * CascadeScale[cascadeIndex].xyz;
	vec3 shadowPosDY = ddy * CascadeScale[cascadeIndex].xyz;

	float lightDepth = shadowPosition.z;
	const float bias = GlobalLightShadowBias;
	lightDepth -= bias;
	vec2 samp = textureLod(sampler2DArray(Textures2DArray[GlobalLightShadowBuffer], CSMTextureSampler), vec3(shadowPosition.xy, cascadeIndex), 0).rg;

	return ChebyshevUpperBound(samp, lightDepth, 0.0001f);
}

#line 209 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
float
CSMPS2(in float Depth, in vec4 PositionShadowSpace, in float NL, in vec3 Normal, out vec4 Debug)
{
#line 211 "G:/nebula/nebula/work/shaders/vk/lib/CSM.fxh"
int cascadeIndex = 4;
	for (int i = 4 - 1; i >= 0; --i)
	{
		if (Depth < CascadeDistances[i])
			cascadeIndex = i;
	}


	if (cascadeIndex == 4)
	{
		Debug = vec4(0,0,0,0);
		return 1.0f;
	}
	else
	{
		Debug = DebugColors[cascadeIndex];
	}

	vec4 shadowPosition = PositionShadowSpace;

	vec3 shadowPosDDX = dFdx(shadowPosition.xyz);
	vec3 shadowPosDDY = dFdy(shadowPosition.xyz);

	float shadowVisibility = SampleShadowCascade(shadowPosition, shadowPosDDX, shadowPosDDY, cascadeIndex);

	return shadowVisibility;
}

#line 72 "G:/nebula/nebula/work/shaders/vk/water.fx"
float
CalculateTessellationFactor(float distance)
{
#line 74 "G:/nebula/nebula/work/shaders/vk/water.fx"
return DynamicTessellationFactor * (1 / (0.015 * distance));
}

#line 79 "G:/nebula/nebula/work/shaders/vk/water.fx"
float
CalculateMIPLevelForDisplacementTextures(float distance)
{
#line 81 "G:/nebula/nebula/work/shaders/vk/water.fx"
return log2(128/CalculateTessellationFactor(distance));
}

#line 85 "G:/nebula/nebula/work/shaders/vk/water.fx"
vec3
CalculateFogColor(vec3 pixel_to_light_vector, vec3 pixel_to_eye_vector)
{
#line 87 "G:/nebula/nebula/work/shaders/vk/water.fx"
return mix(FogDarkColor.rgb,FogBrightColor.rgb,0.5f * dot(pixel_to_light_vector, pixel_to_eye_vector) + 0.5f);
}

#line 90 "G:/nebula/nebula/work/shaders/vk/water.fx"
float
GetRefractionDepth(vec2 position)
{
#line 92 "G:/nebula/nebula/work/shaders/vk/water.fx"
return textureLod(sampler2D(Textures2D[DepthMap], GeometryTextureSampler), position, 0).r;
}

#line 95 "G:/nebula/nebula/work/shaders/vk/water.fx"
float
GetConservativeRefractionDepth(vec2 position)
{
#line 97 "G:/nebula/nebula/work/shaders/vk/water.fx"
vec2 pixelSize = DepthMapPixelSize;
    float result = textureLod(sampler2D(Textures2D[DepthMap], ScreenSampler), position + 2.0 * vec2(pixelSize.x, pixelSize.y), 0).r;
    result = min(result, textureLod(sampler2D(Textures2D[DepthMap], ScreenSampler), position + 2.0 * vec2(pixelSize.x, -pixelSize.y), 0).r);
    result = min(result, textureLod(sampler2D(Textures2D[DepthMap], ScreenSampler), position + 2.0 * vec2(-pixelSize.x, pixelSize.y), 0).r);
    result = min(result, textureLod(sampler2D(Textures2D[DepthMap], ScreenSampler), position + 2.0 * vec2(-pixelSize.x, -pixelSize.y), 0).r);
    return result;
}

#line 109 "G:/nebula/nebula/work/shaders/vk/water.fx"
vec4
CombineWaterNormal(vec3 worldPos)
{
#line 111 "G:/nebula/nebula/work/shaders/vk/water.fx"
vec4 water_normal = vec4(0.0f, 4.0f, 0.0f, 0.0f);
    float water_miplevel;
    float distance_to_camera;
    float disp;
    vec4 norm;
    float texcoord_scale = 1.0f;
    float height_disturbance_scale = 1.0f;
    float normal_disturbance_scale = 1.0f;
    vec2 tc;
    vec2 variance = {1.0f, 1.0f};


    distance_to_camera = distance(EyePos.xyz, worldPos);
    water_miplevel = CalculateMIPLevelForDisplacementTextures(distance_to_camera) / 2.0f - 2.0f;
    tc = (worldPos.xz * WaveScale / TileSize);

    vec2 translation = vec2(TimeAndRandom.x * 1.5f, TimeAndRandom.x * 0.75f) * WaveSpeed;



    for (float i=0; i < 5; i++)
    {
        norm = textureLod(sampler2D(Textures2D[WaveMap], WaveSampler), tc * texcoord_scale + translation * 0.03f * variance, water_miplevel);

        variance.x *= -1.0f;
        water_normal.xz += (2 * norm.xy - vec2(1.0f, 1.0f)) * normal_disturbance_scale;
        water_normal.w += (norm.w - 0.5f) * height_disturbance_scale;
        texcoord_scale *= 1.4f;
        height_disturbance_scale *= 0.65f;
        normal_disturbance_scale *= 0.65f;
    }
    water_normal.w *= WaveHeight;
    return vec4(normalize(water_normal.xyz), water_normal.w);
}

	layout(location = 0) in vec3 WorldPos;
	layout(location = 1) in vec3 ViewSpacePos;
	layout(location = 2) in vec3 Normal;
	layout(location = 3) in vec4 ProjPos;
	layout(location = 4) in vec2 UV;
	layout(location = 5) in vec3 EyeVec;
	layout(location = 6) in float DepthScale;
	layout(location = 0) out vec4 Albedo;
	layout(location = 1) out vec4 Unshaded;
#line 227 "G:/nebula/nebula/work/shaders/vk/water.fx"
void
main()
{
#line 229 "G:/nebula/nebula/work/shaders/vk/water.fx"
vec2 translation = vec2(TimeAndRandom.x * 1.5f, TimeAndRandom.x * 0.75f) * WaveSpeed;

    vec3 tNormal = normalize(2 * texture(sampler2D(Textures2D[WaveMap], WaveSampler), UV - translation * 0.2f).gbr - vec3(1, -8, 1));
    tNormal += normalize(2 * texture(sampler2D(Textures2D[WaveMap], WaveSampler), UV * 0.5f + translation * 0.05f).gbr - vec3(1, -8, 1));


    mat3x3 normal_rotation_matrix;
    normal_rotation_matrix[1] = Normal.xyz;
    normal_rotation_matrix[2] = normalize(cross(vec3(0.0,0.0,-1.0), normal_rotation_matrix[1]));
    normal_rotation_matrix[0] = normalize(cross(normal_rotation_matrix[2], normal_rotation_matrix[1]));
    tNormal = normal_rotation_matrix * normalize(tNormal);


    vec2 pixelSize = ColorMapPixelSize;
    vec2 screenUv = PixelToNormalized(gl_FragCoord.xy, pixelSize.xy);
                                                     
    float shadowFactor = 1.0f;


    float ssDepth = textureLod(sampler2D(Textures2D[DepthMap], ScreenSampler), screenUv, 0).r;
    vec3 pixel_to_eye_vector = normalize(EyeVec);
    vec3 pixel_to_light_vector = normalize(GlobalLightDir.xyz);


    mat4x4 MVP = View * Model;
    mat4x4 MV = View * Model;





    float scatter_factor = 2.5f * max(0.0f, WorldPos.y * 0.25f + 0.25f);


    float distanceToPoint = length(EyeVec);


    float NL = clamp(dot(pixel_to_light_vector, tNormal), 0.0f, 1.0f);
    float NV = clamp(dot(pixel_to_eye_vector, tNormal), 0.0f, 1.0f);


    scatter_factor *= shadowFactor * pow(max(0.0f, dot(normalize(vec3(pixel_to_light_vector.x, 0.0f, pixel_to_light_vector.z)), -pixel_to_eye_vector)), 2.0f);


    scatter_factor *= pow(max(0.0f, 1.0f - NL), 8.0f);


    scatter_factor += shadowFactor * 1.5f * WaterColorIntensity.y * max(0.0f, WorldPos.y + 1) *

        max(0.0f, NV) *

        max(0.0f, 1.0f - pixel_to_eye_vector.y) * (300.0f / (300 + distanceToPoint));


    scatter_factor *= 0.1 + 0.9 * DepthScale;


    float r = (1.2f - 1.0f) / (1.2f + 1.0f);
    float fresnel_factor = max(0.0f, min(1.0f, r + (1.0f - r) * pow(1.0f - NV, 4)));


    vec3 reflected_eye_to_pixel_vector = reflect(-pixel_to_eye_vector, tNormal);

    float specular_factor = shadowFactor * fresnel_factor * pow(max(0.0f, dot(pixel_to_light_vector, reflected_eye_to_pixel_vector)), 1000.0f);


    float diffuse_factor = WaterColorIntensity.x + WaterColorIntensity.y * max(0.0f, NL);


    vec4 disturbance_eyespace = MV * vec4(tNormal.x, 0, tNormal.z, 0);

    vec2 reflection_disturbance = vec2(disturbance_eyespace.x, disturbance_eyespace.z) * 0.03f;
    vec2 refraction_disturbance = vec2(-disturbance_eyespace.x, disturbance_eyespace.y) * 0.05f *

        (20.0/(20 + distanceToPoint));


    vec4 projected_waveheight = MVP * vec4(WorldPos, 1);
    float waveheight_correction = -0.5f * projected_waveheight.y / projected_waveheight.w;
    projected_waveheight = MVP * vec4(WorldPos.x, -0.8f, WorldPos.z, 1);
    waveheight_correction += 0.5f * projected_waveheight.y / projected_waveheight.w;
    reflection_disturbance.y = max(-0.15f, waveheight_correction + reflection_disturbance.y);


    float refraction_depth = GetRefractionDepth(screenUv);


    float depth = length(ViewSpacePos.xyz);
    float water_depth = refraction_depth - depth;
    float nondisplaced_water_depth = water_depth;


    refraction_disturbance *= min(2.0f, water_depth);


    refraction_depth = GetRefractionDepth(screenUv + refraction_disturbance);
    water_depth = refraction_depth - depth;


    float conservative_refraction_depth = GetConservativeRefractionDepth(screenUv + refraction_disturbance);
    float conservative_water_depth = conservative_refraction_depth - depth;

    if (conservative_water_depth < 0)
    {
        refraction_disturbance = vec2(0);
        water_depth = nondisplaced_water_depth;
    }



    water_depth = max(0.0f, water_depth);


    vec4 reflection_color = textureLod(samplerCube(TexturesCube[EnvironmentMap], EnvironmentSampler), reflected_eye_to_pixel_vector + vec3(reflection_disturbance.x, 0, reflection_disturbance.y), 0);

    vec4 refraction_color = textureLod(sampler2D(Textures2D[ColorMap], ScreenSampler), screenUv + refraction_disturbance, 0);


    vec4 water_color = diffuse_factor * vec4(WaterColor.rgb, 1);
    water_color.rgb = mix(CalculateFogColor(pixel_to_light_vector, pixel_to_eye_vector).rgb,water_color.rgb,min(1.0f, exp(-distanceToPoint * FogDensity)));


    fresnel_factor *= min(1.0f, water_depth * 5.0f);


    refraction_color = mix(water_color,refraction_color,min(1.0f, 1.0f * exp(-water_depth / 8.0f)));


    vec4 color;
    color.rgb = mix(refraction_color.rgb,reflection_color.rgb,fresnel_factor);
    color.rgb += 350.0f * specular_factor * WaterSpecular.rgb * fresnel_factor;
    color.rgb += WaterScatterColor.rgb * scatter_factor;
    color.a = 1;
    Albedo = color;
    Unshaded = vec4(color.rgb, fresnel_factor);
}
